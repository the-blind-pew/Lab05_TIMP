        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.3.sdk/usr/include/c++/v1/functional
        -:    0:Graph:/Users/theblindpew/Lab05_TIMP/_build/CMakeFiles/bank_tests.dir/tests/test.cpp.gcno
        -:    0:Data:/Users/theblindpew/Lab05_TIMP/_build/CMakeFiles/bank_tests.dir/tests/test.cpp.gcda
        -:    0:Runs:38
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ functional ----------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_FUNCTIONAL
        -:   11:#define _LIBCPP_FUNCTIONAL
        -:   12:
        -:   13:/*
        -:   14:    functional synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:template <class Arg, class Result>
        -:   20:struct unary_function
        -:   21:{
        -:   22:    typedef Arg    argument_type;
        -:   23:    typedef Result result_type;
        -:   24:};
        -:   25:
        -:   26:template <class Arg1, class Arg2, class Result>
        -:   27:struct binary_function
        -:   28:{
        -:   29:    typedef Arg1   first_argument_type;
        -:   30:    typedef Arg2   second_argument_type;
        -:   31:    typedef Result result_type;
        -:   32:};
        -:   33:
        -:   34:template <class T>
        -:   35:class reference_wrapper
        -:   36:    : public unary_function<T1, R> // if wrapping a unary functor
        -:   37:    : public binary_function<T1, T2, R> // if wraping a binary functor
        -:   38:{
        -:   39:public:
        -:   40:    // types
        -:   41:    typedef T type;
        -:   42:    typedef see below result_type; // Not always defined
        -:   43:
        -:   44:    // construct/copy/destroy
        -:   45:    reference_wrapper(T&) noexcept;
        -:   46:    reference_wrapper(T&&) = delete; // do not bind to temps
        -:   47:    reference_wrapper(const reference_wrapper<T>& x) noexcept;
        -:   48:
        -:   49:    // assignment
        -:   50:    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;
        -:   51:
        -:   52:    // access
        -:   53:    operator T& () const noexcept;
        -:   54:    T& get() const noexcept;
        -:   55:
        -:   56:    // invoke
        -:   57:    template <class... ArgTypes>
        -:   58:      typename result_of<T&(ArgTypes&&...)>::type
        -:   59:          operator() (ArgTypes&&...) const;
        -:   60:};
        -:   61:
        -:   62:template <class T> reference_wrapper<T> ref(T& t) noexcept;
        -:   63:template <class T> void ref(const T&& t) = delete;
        -:   64:template <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;
        -:   65:
        -:   66:template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
        -:   67:template <class T> void cref(const T&& t) = delete;
        -:   68:template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
        -:   69:
        -:   70:template <class T> struct unwrap_reference;                                       // since C++20
        -:   71:template <class T> struct unwrap_ref_decay : unwrap_reference<decay_t<T>> { };    // since C++20
        -:   72:template <class T> using unwrap_reference_t = typename unwrap_reference<T>::type; // since C++20
        -:   73:template <class T> using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type; // since C++20
        -:   74:
        -:   75:template <class T> // <class T=void> in C++14
        -:   76:struct plus : binary_function<T, T, T>
        -:   77:{
        -:   78:    T operator()(const T& x, const T& y) const;
        -:   79:};
        -:   80:
        -:   81:template <class T> // <class T=void> in C++14
        -:   82:struct minus : binary_function<T, T, T>
        -:   83:{
        -:   84:    T operator()(const T& x, const T& y) const;
        -:   85:};
        -:   86:
        -:   87:template <class T> // <class T=void> in C++14
        -:   88:struct multiplies : binary_function<T, T, T>
        -:   89:{
        -:   90:    T operator()(const T& x, const T& y) const;
        -:   91:};
        -:   92:
        -:   93:template <class T> // <class T=void> in C++14
        -:   94:struct divides : binary_function<T, T, T>
        -:   95:{
        -:   96:    T operator()(const T& x, const T& y) const;
        -:   97:};
        -:   98:
        -:   99:template <class T> // <class T=void> in C++14
        -:  100:struct modulus : binary_function<T, T, T>
        -:  101:{
        -:  102:    T operator()(const T& x, const T& y) const;
        -:  103:};
        -:  104:
        -:  105:template <class T> // <class T=void> in C++14
        -:  106:struct negate : unary_function<T, T>
        -:  107:{
        -:  108:    T operator()(const T& x) const;
        -:  109:};
        -:  110:
        -:  111:template <class T> // <class T=void> in C++14
        -:  112:struct equal_to : binary_function<T, T, bool>
        -:  113:{
        -:  114:    bool operator()(const T& x, const T& y) const;
        -:  115:};
        -:  116:
        -:  117:template <class T> // <class T=void> in C++14
        -:  118:struct not_equal_to : binary_function<T, T, bool>
        -:  119:{
        -:  120:    bool operator()(const T& x, const T& y) const;
        -:  121:};
        -:  122:
        -:  123:template <class T> // <class T=void> in C++14
        -:  124:struct greater : binary_function<T, T, bool>
        -:  125:{
        -:  126:    bool operator()(const T& x, const T& y) const;
        -:  127:};
        -:  128:
        -:  129:template <class T> // <class T=void> in C++14
        -:  130:struct less : binary_function<T, T, bool>
        -:  131:{
        -:  132:    bool operator()(const T& x, const T& y) const;
        -:  133:};
        -:  134:
        -:  135:template <class T> // <class T=void> in C++14
        -:  136:struct greater_equal : binary_function<T, T, bool>
        -:  137:{
        -:  138:    bool operator()(const T& x, const T& y) const;
        -:  139:};
        -:  140:
        -:  141:template <class T> // <class T=void> in C++14
        -:  142:struct less_equal : binary_function<T, T, bool>
        -:  143:{
        -:  144:    bool operator()(const T& x, const T& y) const;
        -:  145:};
        -:  146:
        -:  147:template <class T> // <class T=void> in C++14
        -:  148:struct logical_and : binary_function<T, T, bool>
        -:  149:{
        -:  150:    bool operator()(const T& x, const T& y) const;
        -:  151:};
        -:  152:
        -:  153:template <class T> // <class T=void> in C++14
        -:  154:struct logical_or : binary_function<T, T, bool>
        -:  155:{
        -:  156:    bool operator()(const T& x, const T& y) const;
        -:  157:};
        -:  158:
        -:  159:template <class T> // <class T=void> in C++14
        -:  160:struct logical_not : unary_function<T, bool>
        -:  161:{
        -:  162:    bool operator()(const T& x) const;
        -:  163:};
        -:  164:
        -:  165:template <class T> // <class T=void> in C++14
        -:  166:struct bit_and : unary_function<T, bool>
        -:  167:{
        -:  168:    bool operator()(const T& x, const T& y) const;
        -:  169:};
        -:  170:
        -:  171:template <class T> // <class T=void> in C++14
        -:  172:struct bit_or : unary_function<T, bool>
        -:  173:{
        -:  174:    bool operator()(const T& x, const T& y) const;
        -:  175:};
        -:  176:
        -:  177:template <class T> // <class T=void> in C++14
        -:  178:struct bit_xor : unary_function<T, bool>
        -:  179:{
        -:  180:    bool operator()(const T& x, const T& y) const;
        -:  181:};
        -:  182:
        -:  183:template <class T=void> // C++14
        -:  184:struct bit_xor : unary_function<T, bool>
        -:  185:{
        -:  186:    bool operator()(const T& x) const;
        -:  187:};
        -:  188:
        -:  189:template <class Predicate>
        -:  190:class unary_negate // deprecated in C++17
        -:  191:    : public unary_function<typename Predicate::argument_type, bool>
        -:  192:{
        -:  193:public:
        -:  194:    explicit unary_negate(const Predicate& pred);
        -:  195:    bool operator()(const typename Predicate::argument_type& x) const;
        -:  196:};
        -:  197:
        -:  198:template <class Predicate> // deprecated in C++17
        -:  199:unary_negate<Predicate> not1(const Predicate& pred);
        -:  200:
        -:  201:template <class Predicate>
        -:  202:class binary_negate // deprecated in C++17
        -:  203:    : public binary_function<typename Predicate::first_argument_type,
        -:  204:                             typename Predicate::second_argument_type,
        -:  205:                             bool>
        -:  206:{
        -:  207:public:
        -:  208:    explicit binary_negate(const Predicate& pred);
        -:  209:    bool operator()(const typename Predicate::first_argument_type& x,
        -:  210:                    const typename Predicate::second_argument_type& y) const;
        -:  211:};
        -:  212:
        -:  213:template <class Predicate> // deprecated in C++17
        -:  214:binary_negate<Predicate> not2(const Predicate& pred);
        -:  215:
        -:  216:template <class F> unspecified not_fn(F&& f); // C++17
        -:  217:
        -:  218:template<class T> struct is_bind_expression;
        -:  219:template<class T> struct is_placeholder;
        -:  220:
        -:  221:    // See C++14 20.9.9, Function object binders
        -:  222:template <class T> inline constexpr bool is_bind_expression_v
        -:  223:  = is_bind_expression<T>::value; // C++17
        -:  224:template <class T> inline constexpr int is_placeholder_v
        -:  225:  = is_placeholder<T>::value; // C++17
        -:  226:
        -:  227:
        -:  228:template<class Fn, class... BoundArgs>
        -:  229:  unspecified bind(Fn&&, BoundArgs&&...);
        -:  230:template<class R, class Fn, class... BoundArgs>
        -:  231:  unspecified bind(Fn&&, BoundArgs&&...);
        -:  232:
        -:  233:template<class F, class... Args>
        -:  234: invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) // C++17
        -:  235:    noexcept(is_nothrow_invocable_v<F, Args...>);
        -:  236:
        -:  237:namespace placeholders {
        -:  238:  // M is the implementation-defined number of placeholders
        -:  239:  extern unspecified _1;
        -:  240:  extern unspecified _2;
        -:  241:  .
        -:  242:  .
        -:  243:  .
        -:  244:  extern unspecified _Mp;
        -:  245:}
        -:  246:
        -:  247:template <class Operation>
        -:  248:class binder1st     // deprecated in C++11, removed in C++17
        -:  249:    : public unary_function<typename Operation::second_argument_type,
        -:  250:                            typename Operation::result_type>
        -:  251:{
        -:  252:protected:
        -:  253:    Operation                               op;
        -:  254:    typename Operation::first_argument_type value;
        -:  255:public:
        -:  256:    binder1st(const Operation& x, const typename Operation::first_argument_type y);
        -:  257:    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
        -:  258:    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
        -:  259:};
        -:  260:
        -:  261:template <class Operation, class T>
        -:  262:binder1st<Operation> bind1st(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17
        -:  263:
        -:  264:template <class Operation>
        -:  265:class binder2nd     // deprecated in C++11, removed in C++17
        -:  266:    : public unary_function<typename Operation::first_argument_type,
        -:  267:                            typename Operation::result_type>
        -:  268:{
        -:  269:protected:
        -:  270:    Operation                                op;
        -:  271:    typename Operation::second_argument_type value;
        -:  272:public:
        -:  273:    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
        -:  274:    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
        -:  275:    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
        -:  276:};
        -:  277:
        -:  278:template <class Operation, class T>
        -:  279:binder2nd<Operation> bind2nd(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17
        -:  280:
        -:  281:template <class Arg, class Result>      // deprecated in C++11, removed in C++17
        -:  282:class pointer_to_unary_function : public unary_function<Arg, Result>
        -:  283:{
        -:  284:public:
        -:  285:    explicit pointer_to_unary_function(Result (*f)(Arg));
        -:  286:    Result operator()(Arg x) const;
        -:  287:};
        -:  288:
        -:  289:template <class Arg, class Result>
        -:  290:pointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));      // deprecated in C++11, removed in C++17
        -:  291:
        -:  292:template <class Arg1, class Arg2, class Result>      // deprecated in C++11, removed in C++17
        -:  293:class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
        -:  294:{
        -:  295:public:
        -:  296:    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
        -:  297:    Result operator()(Arg1 x, Arg2 y) const;
        -:  298:};
        -:  299:
        -:  300:template <class Arg1, class Arg2, class Result>
        -:  301:pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));      // deprecated in C++11, removed in C++17
        -:  302:
        -:  303:template<class S, class T>      // deprecated in C++11, removed in C++17
        -:  304:class mem_fun_t : public unary_function<T*, S>
        -:  305:{
        -:  306:public:
        -:  307:    explicit mem_fun_t(S (T::*p)());
        -:  308:    S operator()(T* p) const;
        -:  309:};
        -:  310:
        -:  311:template<class S, class T, class A>
        -:  312:class mem_fun1_t : public binary_function<T*, A, S>      // deprecated in C++11, removed in C++17
        -:  313:{
        -:  314:public:
        -:  315:    explicit mem_fun1_t(S (T::*p)(A));
        -:  316:    S operator()(T* p, A x) const;
        -:  317:};
        -:  318:
        -:  319:template<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());      // deprecated in C++11, removed in C++17
        -:  320:template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));     // deprecated in C++11, removed in C++17
        -:  321:
        -:  322:template<class S, class T>
        -:  323:class mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
        -:  324:{
        -:  325:public:
        -:  326:    explicit mem_fun_ref_t(S (T::*p)());
        -:  327:    S operator()(T& p) const;
        -:  328:};
        -:  329:
        -:  330:template<class S, class T, class A>
        -:  331:class mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
        -:  332:{
        -:  333:public:
        -:  334:    explicit mem_fun1_ref_t(S (T::*p)(A));
        -:  335:    S operator()(T& p, A x) const;
        -:  336:};
        -:  337:
        -:  338:template<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());      // deprecated in C++11, removed in C++17
        -:  339:template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));     // deprecated in C++11, removed in C++17
        -:  340:
        -:  341:template <class S, class T>
        -:  342:class const_mem_fun_t : public unary_function<const T*, S>      // deprecated in C++11, removed in C++17
        -:  343:{
        -:  344:public:
        -:  345:    explicit const_mem_fun_t(S (T::*p)() const);
        -:  346:    S operator()(const T* p) const;
        -:  347:};
        -:  348:
        -:  349:template <class S, class T, class A>
        -:  350:class const_mem_fun1_t : public binary_function<const T*, A, S>      // deprecated in C++11, removed in C++17
        -:  351:{
        -:  352:public:
        -:  353:    explicit const_mem_fun1_t(S (T::*p)(A) const);
        -:  354:    S operator()(const T* p, A x) const;
        -:  355:};
        -:  356:
        -:  357:template <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);      // deprecated in C++11, removed in C++17
        -:  358:template <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);     // deprecated in C++11, removed in C++17
        -:  359:
        -:  360:template <class S, class T>
        -:  361:class const_mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
        -:  362:{
        -:  363:public:
        -:  364:    explicit const_mem_fun_ref_t(S (T::*p)() const);
        -:  365:    S operator()(const T& p) const;
        -:  366:};
        -:  367:
        -:  368:template <class S, class T, class A>
        -:  369:class const_mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
        -:  370:{
        -:  371:public:
        -:  372:    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
        -:  373:    S operator()(const T& p, A x) const;
        -:  374:};
        -:  375:
        -:  376:template <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);   // deprecated in C++11, removed in C++17
        -:  377:template <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);  // deprecated in C++11, removed in C++17
        -:  378:
        -:  379:template<class R, class T> unspecified mem_fn(R T::*);
        -:  380:
        -:  381:class bad_function_call
        -:  382:    : public exception
        -:  383:{
        -:  384:};
        -:  385:
        -:  386:template<class> class function; // undefined
        -:  387:
        -:  388:template<class R, class... ArgTypes>
        -:  389:class function<R(ArgTypes...)>
        -:  390:  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
        -:  391:                                      // ArgTypes contains T1
        -:  392:  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
        -:  393:                                      // ArgTypes contains T1 and T2
        -:  394:{
        -:  395:public:
        -:  396:    typedef R result_type;
        -:  397:
        -:  398:    // construct/copy/destroy:
        -:  399:    function() noexcept;
        -:  400:    function(nullptr_t) noexcept;
        -:  401:    function(const function&);
        -:  402:    function(function&&) noexcept;
        -:  403:    template<class F>
        -:  404:      function(F);
        -:  405:    template<Allocator Alloc>
        -:  406:      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17
        -:  407:    template<Allocator Alloc>
        -:  408:      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17
        -:  409:    template<Allocator Alloc>
        -:  410:      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17
        -:  411:    template<Allocator Alloc>
        -:  412:      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17
        -:  413:    template<class F, Allocator Alloc>
        -:  414:      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17
        -:  415:
        -:  416:    function& operator=(const function&);
        -:  417:    function& operator=(function&&) noexcept;
        -:  418:    function& operator=(nullptr_t) noexcept;
        -:  419:    template<class F>
        -:  420:      function& operator=(F&&);
        -:  421:    template<class F>
        -:  422:      function& operator=(reference_wrapper<F>) noexcept;
        -:  423:
        -:  424:    ~function();
        -:  425:
        -:  426:    // function modifiers:
        -:  427:    void swap(function&) noexcept;
        -:  428:    template<class F, class Alloc>
        -:  429:      void assign(F&&, const Alloc&);                 // Removed in C++17
        -:  430:
        -:  431:    // function capacity:
        -:  432:    explicit operator bool() const noexcept;
        -:  433:
        -:  434:    // function invocation:
        -:  435:    R operator()(ArgTypes...) const;
        -:  436:
        -:  437:    // function target access:
        -:  438:    const std::type_info& target_type() const noexcept;
        -:  439:    template <typename T>       T* target() noexcept;
        -:  440:    template <typename T> const T* target() const noexcept;
        -:  441:};
        -:  442:
        -:  443:// Deduction guides
        -:  444:template<class R, class ...Args>
        -:  445:function(R(*)(Args...)) -> function<R(Args...)>; // since C++17
        -:  446:
        -:  447:template<class F>
        -:  448:function(F) -> function<see-below>; // since C++17
        -:  449:
        -:  450:// Null pointer comparisons:
        -:  451:template <class R, class ... ArgTypes>
        -:  452:  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
        -:  453:
        -:  454:template <class R, class ... ArgTypes>
        -:  455:  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
        -:  456:
        -:  457:template <class R, class ... ArgTypes>
        -:  458:  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
        -:  459:
        -:  460:template <class  R, class ... ArgTypes>
        -:  461:  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
        -:  462:
        -:  463:// specialized algorithms:
        -:  464:template <class  R, class ... ArgTypes>
        -:  465:  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
        -:  466:
        -:  467:template <class T> struct hash;
        -:  468:
        -:  469:template <> struct hash<bool>;
        -:  470:template <> struct hash<char>;
        -:  471:template <> struct hash<signed char>;
        -:  472:template <> struct hash<unsigned char>;
        -:  473:template <> struct hash<char16_t>;
        -:  474:template <> struct hash<char32_t>;
        -:  475:template <> struct hash<wchar_t>;
        -:  476:template <> struct hash<short>;
        -:  477:template <> struct hash<unsigned short>;
        -:  478:template <> struct hash<int>;
        -:  479:template <> struct hash<unsigned int>;
        -:  480:template <> struct hash<long>;
        -:  481:template <> struct hash<long long>;
        -:  482:template <> struct hash<unsigned long>;
        -:  483:template <> struct hash<unsigned long long>;
        -:  484:
        -:  485:template <> struct hash<float>;
        -:  486:template <> struct hash<double>;
        -:  487:template <> struct hash<long double>;
        -:  488:
        -:  489:template<class T> struct hash<T*>;
        -:  490:template <> struct hash<nullptr_t>;  // C++17
        -:  491:
        -:  492:}  // std
        -:  493:
        -:  494:POLICY:  For non-variadic implementations, the number of arguments is limited
        -:  495:         to 3.  It is hoped that the need for non-variadic implementations
        -:  496:         will be minimal.
        -:  497:
        -:  498:*/
        -:  499:
        -:  500:#include <__config>
        -:  501:#include <type_traits>
        -:  502:#include <typeinfo>
        -:  503:#include <exception>
        -:  504:#include <memory>
        -:  505:#include <tuple>
        -:  506:#include <utility>
        -:  507:#include <version>
        -:  508:
        -:  509:#include <__functional_base>
        -:  510:
        -:  511:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  512:#pragma GCC system_header
        -:  513:#endif
        -:  514:
        -:  515:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  516:
        -:  517:#if _LIBCPP_STD_VER > 11
        -:  518:template <class _Tp = void>
        -:  519:#else
        -:  520:template <class _Tp>
        -:  521:#endif
        -:  522:struct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>
        -:  523:{
        -:  524:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  525:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  526:        {return __x + __y;}
        -:  527:};
        -:  528:
        -:  529:#if _LIBCPP_STD_VER > 11
        -:  530:template <>
        -:  531:struct _LIBCPP_TEMPLATE_VIS plus<void>
        -:  532:{
        -:  533:    template <class _T1, class _T2>
        -:  534:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  535:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  536:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))
        -:  537:    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))
        -:  538:        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
        -:  539:    typedef void is_transparent;
        -:  540:};
        -:  541:#endif
        -:  542:
        -:  543:
        -:  544:#if _LIBCPP_STD_VER > 11
        -:  545:template <class _Tp = void>
        -:  546:#else
        -:  547:template <class _Tp>
        -:  548:#endif
        -:  549:struct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>
        -:  550:{
        -:  551:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  552:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  553:        {return __x - __y;}
        -:  554:};
        -:  555:
        -:  556:#if _LIBCPP_STD_VER > 11
        -:  557:template <>
        -:  558:struct _LIBCPP_TEMPLATE_VIS minus<void>
        -:  559:{
        -:  560:    template <class _T1, class _T2>
        -:  561:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  562:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  563:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))
        -:  564:    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))
        -:  565:        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }
        -:  566:    typedef void is_transparent;
        -:  567:};
        -:  568:#endif
        -:  569:
        -:  570:
        -:  571:#if _LIBCPP_STD_VER > 11
        -:  572:template <class _Tp = void>
        -:  573:#else
        -:  574:template <class _Tp>
        -:  575:#endif
        -:  576:struct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>
        -:  577:{
        -:  578:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  579:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  580:        {return __x * __y;}
        -:  581:};
        -:  582:
        -:  583:#if _LIBCPP_STD_VER > 11
        -:  584:template <>
        -:  585:struct _LIBCPP_TEMPLATE_VIS multiplies<void>
        -:  586:{
        -:  587:    template <class _T1, class _T2>
        -:  588:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  589:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  590:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))
        -:  591:    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))
        -:  592:        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }
        -:  593:    typedef void is_transparent;
        -:  594:};
        -:  595:#endif
        -:  596:
        -:  597:
        -:  598:#if _LIBCPP_STD_VER > 11
        -:  599:template <class _Tp = void>
        -:  600:#else
        -:  601:template <class _Tp>
        -:  602:#endif
        -:  603:struct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>
        -:  604:{
        -:  605:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  606:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  607:        {return __x / __y;}
        -:  608:};
        -:  609:
        -:  610:#if _LIBCPP_STD_VER > 11
        -:  611:template <>
        -:  612:struct _LIBCPP_TEMPLATE_VIS divides<void>
        -:  613:{
        -:  614:    template <class _T1, class _T2>
        -:  615:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  616:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  617:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))
        -:  618:    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))
        -:  619:        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }
        -:  620:    typedef void is_transparent;
        -:  621:};
        -:  622:#endif
        -:  623:
        -:  624:
        -:  625:#if _LIBCPP_STD_VER > 11
        -:  626:template <class _Tp = void>
        -:  627:#else
        -:  628:template <class _Tp>
        -:  629:#endif
        -:  630:struct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>
        -:  631:{
        -:  632:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  633:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  634:        {return __x % __y;}
        -:  635:};
        -:  636:
        -:  637:#if _LIBCPP_STD_VER > 11
        -:  638:template <>
        -:  639:struct _LIBCPP_TEMPLATE_VIS modulus<void>
        -:  640:{
        -:  641:    template <class _T1, class _T2>
        -:  642:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  643:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  644:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))
        -:  645:    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))
        -:  646:        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }
        -:  647:    typedef void is_transparent;
        -:  648:};
        -:  649:#endif
        -:  650:
        -:  651:
        -:  652:#if _LIBCPP_STD_VER > 11
        -:  653:template <class _Tp = void>
        -:  654:#else
        -:  655:template <class _Tp>
        -:  656:#endif
        -:  657:struct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>
        -:  658:{
        -:  659:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  660:    _Tp operator()(const _Tp& __x) const
        -:  661:        {return -__x;}
        -:  662:};
        -:  663:
        -:  664:#if _LIBCPP_STD_VER > 11
        -:  665:template <>
        -:  666:struct _LIBCPP_TEMPLATE_VIS negate<void>
        -:  667:{
        -:  668:    template <class _Tp>
        -:  669:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  670:    auto operator()(_Tp&& __x) const
        -:  671:    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))
        -:  672:    -> decltype        (- _VSTD::forward<_Tp>(__x))
        -:  673:        { return        - _VSTD::forward<_Tp>(__x); }
        -:  674:    typedef void is_transparent;
        -:  675:};
        -:  676:#endif
        -:  677:
        -:  678:
        -:  679:#if _LIBCPP_STD_VER > 11
        -:  680:template <class _Tp = void>
        -:  681:#else
        -:  682:template <class _Tp>
        -:  683:#endif
        -:  684:struct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>
        -:  685:{
        -:  686:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  687:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  688:        {return __x == __y;}
        -:  689:};
        -:  690:
        -:  691:#if _LIBCPP_STD_VER > 11
        -:  692:template <>
        -:  693:struct _LIBCPP_TEMPLATE_VIS equal_to<void>
        -:  694:{
        -:  695:    template <class _T1, class _T2>
        -:  696:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  697:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  698:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))
        -:  699:    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))
        -:  700:        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }
        -:  701:    typedef void is_transparent;
        -:  702:};
        -:  703:#endif
        -:  704:
        -:  705:
        -:  706:#if _LIBCPP_STD_VER > 11
        -:  707:template <class _Tp = void>
        -:  708:#else
        -:  709:template <class _Tp>
        -:  710:#endif
        -:  711:struct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>
        -:  712:{
        -:  713:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  714:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  715:        {return __x != __y;}
        -:  716:};
        -:  717:
        -:  718:#if _LIBCPP_STD_VER > 11
        -:  719:template <>
        -:  720:struct _LIBCPP_TEMPLATE_VIS not_equal_to<void>
        -:  721:{
        -:  722:    template <class _T1, class _T2>
        -:  723:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  724:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  725:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))
        -:  726:    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))
        -:  727:        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }
        -:  728:    typedef void is_transparent;
        -:  729:};
        -:  730:#endif
        -:  731:
        -:  732:
        -:  733:#if _LIBCPP_STD_VER > 11
        -:  734:template <class _Tp = void>
        -:  735:#else
        -:  736:template <class _Tp>
        -:  737:#endif
        -:  738:struct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>
        -:  739:{
        -:  740:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  741:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  742:        {return __x > __y;}
        -:  743:};
        -:  744:
        -:  745:#if _LIBCPP_STD_VER > 11
        -:  746:template <>
        -:  747:struct _LIBCPP_TEMPLATE_VIS greater<void>
        -:  748:{
        -:  749:    template <class _T1, class _T2>
        -:  750:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  751:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  752:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))
        -:  753:    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))
        -:  754:        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }
        -:  755:    typedef void is_transparent;
        -:  756:};
        -:  757:#endif
        -:  758:
        -:  759:
        -:  760:// less in <__functional_base>
        -:  761:
        -:  762:#if _LIBCPP_STD_VER > 11
        -:  763:template <class _Tp = void>
        -:  764:#else
        -:  765:template <class _Tp>
        -:  766:#endif
        -:  767:struct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>
        -:  768:{
        -:  769:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  770:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  771:        {return __x >= __y;}
        -:  772:};
        -:  773:
        -:  774:#if _LIBCPP_STD_VER > 11
        -:  775:template <>
        -:  776:struct _LIBCPP_TEMPLATE_VIS greater_equal<void>
        -:  777:{
        -:  778:    template <class _T1, class _T2>
        -:  779:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  780:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  781:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))
        -:  782:    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))
        -:  783:        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }
        -:  784:    typedef void is_transparent;
        -:  785:};
        -:  786:#endif
        -:  787:
        -:  788:
        -:  789:#if _LIBCPP_STD_VER > 11
        -:  790:template <class _Tp = void>
        -:  791:#else
        -:  792:template <class _Tp>
        -:  793:#endif
        -:  794:struct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>
        -:  795:{
        -:  796:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  797:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  798:        {return __x <= __y;}
        -:  799:};
        -:  800:
        -:  801:#if _LIBCPP_STD_VER > 11
        -:  802:template <>
        -:  803:struct _LIBCPP_TEMPLATE_VIS less_equal<void>
        -:  804:{
        -:  805:    template <class _T1, class _T2>
        -:  806:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  807:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  808:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))
        -:  809:    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))
        -:  810:        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }
        -:  811:    typedef void is_transparent;
        -:  812:};
        -:  813:#endif
        -:  814:
        -:  815:
        -:  816:#if _LIBCPP_STD_VER > 11
        -:  817:template <class _Tp = void>
        -:  818:#else
        -:  819:template <class _Tp>
        -:  820:#endif
        -:  821:struct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>
        -:  822:{
        -:  823:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  824:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  825:        {return __x && __y;}
        -:  826:};
        -:  827:
        -:  828:#if _LIBCPP_STD_VER > 11
        -:  829:template <>
        -:  830:struct _LIBCPP_TEMPLATE_VIS logical_and<void>
        -:  831:{
        -:  832:    template <class _T1, class _T2>
        -:  833:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  834:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  835:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))
        -:  836:    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))
        -:  837:        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }
        -:  838:    typedef void is_transparent;
        -:  839:};
        -:  840:#endif
        -:  841:
        -:  842:
        -:  843:#if _LIBCPP_STD_VER > 11
        -:  844:template <class _Tp = void>
        -:  845:#else
        -:  846:template <class _Tp>
        -:  847:#endif
        -:  848:struct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>
        -:  849:{
        -:  850:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  851:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:  852:        {return __x || __y;}
        -:  853:};
        -:  854:
        -:  855:#if _LIBCPP_STD_VER > 11
        -:  856:template <>
        -:  857:struct _LIBCPP_TEMPLATE_VIS logical_or<void>
        -:  858:{
        -:  859:    template <class _T1, class _T2>
        -:  860:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  861:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  862:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))
        -:  863:    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))
        -:  864:        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }
        -:  865:    typedef void is_transparent;
        -:  866:};
        -:  867:#endif
        -:  868:
        -:  869:
        -:  870:#if _LIBCPP_STD_VER > 11
        -:  871:template <class _Tp = void>
        -:  872:#else
        -:  873:template <class _Tp>
        -:  874:#endif
        -:  875:struct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>
        -:  876:{
        -:  877:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  878:    bool operator()(const _Tp& __x) const
        -:  879:        {return !__x;}
        -:  880:};
        -:  881:
        -:  882:#if _LIBCPP_STD_VER > 11
        -:  883:template <>
        -:  884:struct _LIBCPP_TEMPLATE_VIS logical_not<void>
        -:  885:{
        -:  886:    template <class _Tp>
        -:  887:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  888:    auto operator()(_Tp&& __x) const
        -:  889:    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))
        -:  890:    -> decltype        (!_VSTD::forward<_Tp>(__x))
        -:  891:        { return        !_VSTD::forward<_Tp>(__x); }
        -:  892:    typedef void is_transparent;
        -:  893:};
        -:  894:#endif
        -:  895:
        -:  896:
        -:  897:#if _LIBCPP_STD_VER > 11
        -:  898:template <class _Tp = void>
        -:  899:#else
        -:  900:template <class _Tp>
        -:  901:#endif
        -:  902:struct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>
        -:  903:{
        -:  904:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  905:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  906:        {return __x & __y;}
        -:  907:};
        -:  908:
        -:  909:#if _LIBCPP_STD_VER > 11
        -:  910:template <>
        -:  911:struct _LIBCPP_TEMPLATE_VIS bit_and<void>
        -:  912:{
        -:  913:    template <class _T1, class _T2>
        -:  914:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  915:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  916:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))
        -:  917:    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))
        -:  918:        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }
        -:  919:    typedef void is_transparent;
        -:  920:};
        -:  921:#endif
        -:  922:
        -:  923:
        -:  924:#if _LIBCPP_STD_VER > 11
        -:  925:template <class _Tp = void>
        -:  926:#else
        -:  927:template <class _Tp>
        -:  928:#endif
        -:  929:struct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>
        -:  930:{
        -:  931:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  932:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  933:        {return __x | __y;}
        -:  934:};
        -:  935:
        -:  936:#if _LIBCPP_STD_VER > 11
        -:  937:template <>
        -:  938:struct _LIBCPP_TEMPLATE_VIS bit_or<void>
        -:  939:{
        -:  940:    template <class _T1, class _T2>
        -:  941:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  942:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  943:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))
        -:  944:    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))
        -:  945:        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }
        -:  946:    typedef void is_transparent;
        -:  947:};
        -:  948:#endif
        -:  949:
        -:  950:
        -:  951:#if _LIBCPP_STD_VER > 11
        -:  952:template <class _Tp = void>
        -:  953:#else
        -:  954:template <class _Tp>
        -:  955:#endif
        -:  956:struct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>
        -:  957:{
        -:  958:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  959:    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        -:  960:        {return __x ^ __y;}
        -:  961:};
        -:  962:
        -:  963:#if _LIBCPP_STD_VER > 11
        -:  964:template <>
        -:  965:struct _LIBCPP_TEMPLATE_VIS bit_xor<void>
        -:  966:{
        -:  967:    template <class _T1, class _T2>
        -:  968:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  969:    auto operator()(_T1&& __t, _T2&& __u) const
        -:  970:    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))
        -:  971:    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))
        -:  972:        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }
        -:  973:    typedef void is_transparent;
        -:  974:};
        -:  975:#endif
        -:  976:
        -:  977:
        -:  978:#if _LIBCPP_STD_VER > 11
        -:  979:template <class _Tp = void>
        -:  980:struct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>
        -:  981:{
        -:  982:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  983:    _Tp operator()(const _Tp& __x) const
        -:  984:        {return ~__x;}
        -:  985:};
        -:  986:
        -:  987:template <>
        -:  988:struct _LIBCPP_TEMPLATE_VIS bit_not<void>
        -:  989:{
        -:  990:    template <class _Tp>
        -:  991:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:  992:    auto operator()(_Tp&& __x) const
        -:  993:    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))
        -:  994:    -> decltype        (~_VSTD::forward<_Tp>(__x))
        -:  995:        { return        ~_VSTD::forward<_Tp>(__x); }
        -:  996:    typedef void is_transparent;
        -:  997:};
        -:  998:#endif
        -:  999:
        -: 1000:template <class _Predicate>
        -: 1001:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 unary_negate
        -: 1002:    : public unary_function<typename _Predicate::argument_type, bool>
        -: 1003:{
        -: 1004:    _Predicate __pred_;
        -: 1005:public:
        -: 1006:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1007:    explicit unary_negate(const _Predicate& __pred)
        -: 1008:        : __pred_(__pred) {}
        -: 1009:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1010:    bool operator()(const typename _Predicate::argument_type& __x) const
        -: 1011:        {return !__pred_(__x);}
        -: 1012:};
        -: 1013:
        -: 1014:template <class _Predicate>
        -: 1015:_LIBCPP_DEPRECATED_IN_CXX17 inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1016:unary_negate<_Predicate>
        -: 1017:not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}
        -: 1018:
        -: 1019:template <class _Predicate>
        -: 1020:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX17 binary_negate
        -: 1021:    : public binary_function<typename _Predicate::first_argument_type,
        -: 1022:                             typename _Predicate::second_argument_type,
        -: 1023:                             bool>
        -: 1024:{
        -: 1025:    _Predicate __pred_;
        -: 1026:public:
        -: 1027:    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1028:    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}
        -: 1029:
        -: 1030:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1031:    bool operator()(const typename _Predicate::first_argument_type& __x,
        -: 1032:                    const typename _Predicate::second_argument_type& __y) const
        -: 1033:        {return !__pred_(__x, __y);}
        -: 1034:};
        -: 1035:
        -: 1036:template <class _Predicate>
        -: 1037:_LIBCPP_DEPRECATED_IN_CXX17 inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -: 1038:binary_negate<_Predicate>
        -: 1039:not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}
        -: 1040:
        -: 1041:#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_BINDERS)
        -: 1042:template <class __Operation>
        -: 1043:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 binder1st
        -: 1044:    : public unary_function<typename __Operation::second_argument_type,
        -: 1045:                            typename __Operation::result_type>
        -: 1046:{
        -: 1047:protected:
        -: 1048:    __Operation                               op;
        -: 1049:    typename __Operation::first_argument_type value;
        -: 1050:public:
        -: 1051:    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,
        -: 1052:                               const typename __Operation::first_argument_type __y)
        -: 1053:        : op(__x), value(__y) {}
        -: 1054:    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        -: 1055:        (typename __Operation::second_argument_type& __x) const
        -: 1056:            {return op(value, __x);}
        -: 1057:    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        -: 1058:        (const typename __Operation::second_argument_type& __x) const
        -: 1059:            {return op(value, __x);}
        -: 1060:};
        -: 1061:
        -: 1062:template <class __Operation, class _Tp>
        -: 1063:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1064:binder1st<__Operation>
        -: 1065:bind1st(const __Operation& __op, const _Tp& __x)
        -: 1066:    {return binder1st<__Operation>(__op, __x);}
        -: 1067:
        -: 1068:template <class __Operation>
        -: 1069:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 binder2nd
        -: 1070:    : public unary_function<typename __Operation::first_argument_type,
        -: 1071:                            typename __Operation::result_type>
        -: 1072:{
        -: 1073:protected:
        -: 1074:    __Operation                                op;
        -: 1075:    typename __Operation::second_argument_type value;
        -: 1076:public:
        -: 1077:    _LIBCPP_INLINE_VISIBILITY
        -: 1078:    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        -: 1079:        : op(__x), value(__y) {}
        -: 1080:    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        -: 1081:        (      typename __Operation::first_argument_type& __x) const
        -: 1082:            {return op(__x, value);}
        -: 1083:    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()
        -: 1084:        (const typename __Operation::first_argument_type& __x) const
        -: 1085:            {return op(__x, value);}
        -: 1086:};
        -: 1087:
        -: 1088:template <class __Operation, class _Tp>
        -: 1089:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1090:binder2nd<__Operation>
        -: 1091:bind2nd(const __Operation& __op, const _Tp& __x)
        -: 1092:    {return binder2nd<__Operation>(__op, __x);}
        -: 1093:
        -: 1094:template <class _Arg, class _Result>
        -: 1095:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 pointer_to_unary_function
        -: 1096:    : public unary_function<_Arg, _Result>
        -: 1097:{
        -: 1098:    _Result (*__f_)(_Arg);
        -: 1099:public:
        -: 1100:    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        -: 1101:        : __f_(__f) {}
        -: 1102:    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const
        -: 1103:        {return __f_(__x);}
        -: 1104:};
        -: 1105:
        -: 1106:template <class _Arg, class _Result>
        -: 1107:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1108:pointer_to_unary_function<_Arg,_Result>
        -: 1109:ptr_fun(_Result (*__f)(_Arg))
        -: 1110:    {return pointer_to_unary_function<_Arg,_Result>(__f);}
        -: 1111:
        -: 1112:template <class _Arg1, class _Arg2, class _Result>
        -: 1113:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 pointer_to_binary_function
        -: 1114:    : public binary_function<_Arg1, _Arg2, _Result>
        -: 1115:{
        -: 1116:    _Result (*__f_)(_Arg1, _Arg2);
        -: 1117:public:
        -: 1118:    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        -: 1119:        : __f_(__f) {}
        -: 1120:    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const
        -: 1121:        {return __f_(__x, __y);}
        -: 1122:};
        -: 1123:
        -: 1124:template <class _Arg1, class _Arg2, class _Result>
        -: 1125:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1126:pointer_to_binary_function<_Arg1,_Arg2,_Result>
        -: 1127:ptr_fun(_Result (*__f)(_Arg1,_Arg2))
        -: 1128:    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}
        -: 1129:
        -: 1130:template<class _Sp, class _Tp>
        -: 1131:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun_t
        -: 1132:    : public unary_function<_Tp*, _Sp>
        -: 1133:{
        -: 1134:    _Sp (_Tp::*__p_)();
        -: 1135:public:
        -: 1136:    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())
        -: 1137:        : __p_(__p) {}
        -: 1138:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const
        -: 1139:        {return (__p->*__p_)();}
        -: 1140:};
        -: 1141:
        -: 1142:template<class _Sp, class _Tp, class _Ap>
        -: 1143:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun1_t
        -: 1144:    : public binary_function<_Tp*, _Ap, _Sp>
        -: 1145:{
        -: 1146:    _Sp (_Tp::*__p_)(_Ap);
        -: 1147:public:
        -: 1148:    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        -: 1149:        : __p_(__p) {}
        -: 1150:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const
        -: 1151:        {return (__p->*__p_)(__x);}
        -: 1152:};
        -: 1153:
        -: 1154:template<class _Sp, class _Tp>
        -: 1155:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1156:mem_fun_t<_Sp,_Tp>
        -: 1157:mem_fun(_Sp (_Tp::*__f)())
        -: 1158:    {return mem_fun_t<_Sp,_Tp>(__f);}
        -: 1159:
        -: 1160:template<class _Sp, class _Tp, class _Ap>
        -: 1161:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1162:mem_fun1_t<_Sp,_Tp,_Ap>
        -: 1163:mem_fun(_Sp (_Tp::*__f)(_Ap))
        -: 1164:    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}
        -: 1165:
        -: 1166:template<class _Sp, class _Tp>
        -: 1167:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun_ref_t
        -: 1168:    : public unary_function<_Tp, _Sp>
        -: 1169:{
        -: 1170:    _Sp (_Tp::*__p_)();
        -: 1171:public:
        -: 1172:    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        -: 1173:        : __p_(__p) {}
        -: 1174:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const
        -: 1175:        {return (__p.*__p_)();}
        -: 1176:};
        -: 1177:
        -: 1178:template<class _Sp, class _Tp, class _Ap>
        -: 1179:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 mem_fun1_ref_t
        -: 1180:    : public binary_function<_Tp, _Ap, _Sp>
        -: 1181:{
        -: 1182:    _Sp (_Tp::*__p_)(_Ap);
        -: 1183:public:
        -: 1184:    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        -: 1185:        : __p_(__p) {}
        -: 1186:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const
        -: 1187:        {return (__p.*__p_)(__x);}
        -: 1188:};
        -: 1189:
        -: 1190:template<class _Sp, class _Tp>
        -: 1191:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1192:mem_fun_ref_t<_Sp,_Tp>
        -: 1193:mem_fun_ref(_Sp (_Tp::*__f)())
        -: 1194:    {return mem_fun_ref_t<_Sp,_Tp>(__f);}
        -: 1195:
        -: 1196:template<class _Sp, class _Tp, class _Ap>
        -: 1197:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1198:mem_fun1_ref_t<_Sp,_Tp,_Ap>
        -: 1199:mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
        -: 1200:    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}
        -: 1201:
        -: 1202:template <class _Sp, class _Tp>
        -: 1203:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun_t
        -: 1204:    : public unary_function<const _Tp*, _Sp>
        -: 1205:{
        -: 1206:    _Sp (_Tp::*__p_)() const;
        -: 1207:public:
        -: 1208:    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        -: 1209:        : __p_(__p) {}
        -: 1210:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const
        -: 1211:        {return (__p->*__p_)();}
        -: 1212:};
        -: 1213:
        -: 1214:template <class _Sp, class _Tp, class _Ap>
        -: 1215:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun1_t
        -: 1216:    : public binary_function<const _Tp*, _Ap, _Sp>
        -: 1217:{
        -: 1218:    _Sp (_Tp::*__p_)(_Ap) const;
        -: 1219:public:
        -: 1220:    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        -: 1221:        : __p_(__p) {}
        -: 1222:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const
        -: 1223:        {return (__p->*__p_)(__x);}
        -: 1224:};
        -: 1225:
        -: 1226:template <class _Sp, class _Tp>
        -: 1227:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1228:const_mem_fun_t<_Sp,_Tp>
        -: 1229:mem_fun(_Sp (_Tp::*__f)() const)
        -: 1230:    {return const_mem_fun_t<_Sp,_Tp>(__f);}
        -: 1231:
        -: 1232:template <class _Sp, class _Tp, class _Ap>
        -: 1233:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1234:const_mem_fun1_t<_Sp,_Tp,_Ap>
        -: 1235:mem_fun(_Sp (_Tp::*__f)(_Ap) const)
        -: 1236:    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}
        -: 1237:
        -: 1238:template <class _Sp, class _Tp>
        -: 1239:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun_ref_t
        -: 1240:    : public unary_function<_Tp, _Sp>
        -: 1241:{
        -: 1242:    _Sp (_Tp::*__p_)() const;
        -: 1243:public:
        -: 1244:    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        -: 1245:        : __p_(__p) {}
        -: 1246:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const
        -: 1247:        {return (__p.*__p_)();}
        -: 1248:};
        -: 1249:
        -: 1250:template <class _Sp, class _Tp, class _Ap>
        -: 1251:class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 const_mem_fun1_ref_t
        -: 1252:    : public binary_function<_Tp, _Ap, _Sp>
        -: 1253:{
        -: 1254:    _Sp (_Tp::*__p_)(_Ap) const;
        -: 1255:public:
        -: 1256:    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        -: 1257:        : __p_(__p) {}
        -: 1258:    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const
        -: 1259:        {return (__p.*__p_)(__x);}
        -: 1260:};
        -: 1261:
        -: 1262:template <class _Sp, class _Tp>
        -: 1263:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1264:const_mem_fun_ref_t<_Sp,_Tp>
        -: 1265:mem_fun_ref(_Sp (_Tp::*__f)() const)
        -: 1266:    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}
        -: 1267:
        -: 1268:template <class _Sp, class _Tp, class _Ap>
        -: 1269:_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
        -: 1270:const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
        -: 1271:mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
        -: 1272:    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}
        -: 1273:#endif
        -: 1274:
        -: 1275:////////////////////////////////////////////////////////////////////////////////
        -: 1276://                                MEMFUN
        -: 1277://==============================================================================
        -: 1278:
        -: 1279:template <class _Tp>
        -: 1280:class __mem_fn
        -: 1281:    : public __weak_result_type<_Tp>
        -: 1282:{
        -: 1283:public:
        -: 1284:    // types
        -: 1285:    typedef _Tp type;
        -: 1286:private:
        -: 1287:    type __f_;
        -: 1288:
        -: 1289:public:
        -: 1290:    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}
        -: 1291:
        -: 1292:#ifndef _LIBCPP_CXX03_LANG
        -: 1293:    // invoke
        -: 1294:    template <class... _ArgTypes>
        -: 1295:    _LIBCPP_INLINE_VISIBILITY
        -: 1296:    typename __invoke_return<type, _ArgTypes...>::type
        -: 1297:    operator() (_ArgTypes&&... __args) const {
        -: 1298:        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);
        -: 1299:    }
        -: 1300:#else
        -: 1301:
        -: 1302:    template <class _A0>
        -: 1303:    _LIBCPP_INLINE_VISIBILITY
        -: 1304:    typename __invoke_return0<type, _A0>::type
        -: 1305:    operator() (_A0& __a0) const {
        -: 1306:        return __invoke(__f_, __a0);
        -: 1307:    }
        -: 1308:
        -: 1309:    template <class _A0>
        -: 1310:    _LIBCPP_INLINE_VISIBILITY
        -: 1311:    typename __invoke_return0<type, _A0 const>::type
        -: 1312:    operator() (_A0 const& __a0) const {
        -: 1313:        return __invoke(__f_, __a0);
        -: 1314:    }
        -: 1315:
        -: 1316:    template <class _A0, class _A1>
        -: 1317:    _LIBCPP_INLINE_VISIBILITY
        -: 1318:    typename __invoke_return1<type, _A0, _A1>::type
        -: 1319:    operator() (_A0& __a0, _A1& __a1) const {
        -: 1320:        return __invoke(__f_, __a0, __a1);
        -: 1321:    }
        -: 1322:
        -: 1323:    template <class _A0, class _A1>
        -: 1324:    _LIBCPP_INLINE_VISIBILITY
        -: 1325:    typename __invoke_return1<type, _A0 const, _A1>::type
        -: 1326:    operator() (_A0 const& __a0, _A1& __a1) const {
        -: 1327:        return __invoke(__f_, __a0, __a1);
        -: 1328:    }
        -: 1329:
        -: 1330:    template <class _A0, class _A1>
        -: 1331:    _LIBCPP_INLINE_VISIBILITY
        -: 1332:    typename __invoke_return1<type, _A0, _A1 const>::type
        -: 1333:    operator() (_A0& __a0, _A1 const& __a1) const {
        -: 1334:        return __invoke(__f_, __a0, __a1);
        -: 1335:    }
        -: 1336:
        -: 1337:    template <class _A0, class _A1>
        -: 1338:    _LIBCPP_INLINE_VISIBILITY
        -: 1339:    typename __invoke_return1<type, _A0 const, _A1 const>::type
        -: 1340:    operator() (_A0 const& __a0, _A1 const& __a1) const {
        -: 1341:        return __invoke(__f_, __a0, __a1);
        -: 1342:    }
        -: 1343:
        -: 1344:    template <class _A0, class _A1, class _A2>
        -: 1345:    _LIBCPP_INLINE_VISIBILITY
        -: 1346:    typename __invoke_return2<type, _A0, _A1, _A2>::type
        -: 1347:    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {
        -: 1348:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1349:    }
        -: 1350:
        -: 1351:    template <class _A0, class _A1, class _A2>
        -: 1352:    _LIBCPP_INLINE_VISIBILITY
        -: 1353:    typename __invoke_return2<type, _A0 const, _A1, _A2>::type
        -: 1354:    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {
        -: 1355:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1356:    }
        -: 1357:
        -: 1358:    template <class _A0, class _A1, class _A2>
        -: 1359:    _LIBCPP_INLINE_VISIBILITY
        -: 1360:    typename __invoke_return2<type, _A0, _A1 const, _A2>::type
        -: 1361:    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {
        -: 1362:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1363:    }
        -: 1364:
        -: 1365:    template <class _A0, class _A1, class _A2>
        -: 1366:    _LIBCPP_INLINE_VISIBILITY
        -: 1367:    typename __invoke_return2<type, _A0, _A1, _A2 const>::type
        -: 1368:    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {
        -: 1369:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1370:    }
        -: 1371:
        -: 1372:    template <class _A0, class _A1, class _A2>
        -: 1373:    _LIBCPP_INLINE_VISIBILITY
        -: 1374:    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type
        -: 1375:    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {
        -: 1376:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1377:    }
        -: 1378:
        -: 1379:    template <class _A0, class _A1, class _A2>
        -: 1380:    _LIBCPP_INLINE_VISIBILITY
        -: 1381:    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type
        -: 1382:    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {
        -: 1383:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1384:    }
        -: 1385:
        -: 1386:    template <class _A0, class _A1, class _A2>
        -: 1387:    _LIBCPP_INLINE_VISIBILITY
        -: 1388:    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type
        -: 1389:    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {
        -: 1390:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1391:    }
        -: 1392:
        -: 1393:    template <class _A0, class _A1, class _A2>
        -: 1394:    _LIBCPP_INLINE_VISIBILITY
        -: 1395:    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type
        -: 1396:    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {
        -: 1397:        return __invoke(__f_, __a0, __a1, __a2);
        -: 1398:    }
        -: 1399:#endif
        -: 1400:};
        -: 1401:
        -: 1402:template<class _Rp, class _Tp>
        -: 1403:inline _LIBCPP_INLINE_VISIBILITY
        -: 1404:__mem_fn<_Rp _Tp::*>
        -: 1405:mem_fn(_Rp _Tp::* __pm) _NOEXCEPT
        -: 1406:{
        -: 1407:    return __mem_fn<_Rp _Tp::*>(__pm);
        -: 1408:}
        -: 1409:
        -: 1410:////////////////////////////////////////////////////////////////////////////////
        -: 1411://                                FUNCTION
        -: 1412://==============================================================================
        -: 1413:
        -: 1414:// bad_function_call
        -: 1415:
    #####: 1416:class _LIBCPP_EXCEPTION_ABI bad_function_call
        -: 1417:    : public exception
        -: 1418:{
        -: 1419:#ifdef _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION
        -: 1420:public:
        -: 1421:    virtual ~bad_function_call() _NOEXCEPT;
        -: 1422:
        -: 1423:    virtual const char* what() const _NOEXCEPT;
        -: 1424:#endif
        -: 1425:};
        -: 1426:
        -: 1427:_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
    #####: 1428:void __throw_bad_function_call()
        -: 1429:{
        -: 1430:#ifndef _LIBCPP_NO_EXCEPTIONS
    #####: 1431:    throw bad_function_call();
        -: 1432:#else
        -: 1433:    _VSTD::abort();
        -: 1434:#endif
        -: 1435:}
        -: 1436:
        -: 1437:#if defined(_LIBCPP_CXX03_LANG) && !defined(_LIBCPP_DISABLE_DEPRECATION_WARNINGS) && __has_attribute(deprecated)
        -: 1438:#   define _LIBCPP_DEPRECATED_CXX03_FUNCTION \
        -: 1439:        __attribute__((deprecated("Using std::function in C++03 is not supported anymore. Please upgrade to C++11 or later, or use a different type")))
        -: 1440:#else
        -: 1441:#   define _LIBCPP_DEPRECATED_CXX03_FUNCTION /* nothing */
        -: 1442:#endif
        -: 1443:
        -: 1444:template<class _Fp> class _LIBCPP_DEPRECATED_CXX03_FUNCTION _LIBCPP_TEMPLATE_VIS function; // undefined
        -: 1445:
        -: 1446:namespace __function
        -: 1447:{
        -: 1448:
        -: 1449:template<class _Rp>
        -: 1450:struct __maybe_derive_from_unary_function
        -: 1451:{
        -: 1452:};
        -: 1453:
        -: 1454:template<class _Rp, class _A1>
        -: 1455:struct __maybe_derive_from_unary_function<_Rp(_A1)>
        -: 1456:    : public unary_function<_A1, _Rp>
        -: 1457:{
        -: 1458:};
        -: 1459:
        -: 1460:template<class _Rp>
        -: 1461:struct __maybe_derive_from_binary_function
        -: 1462:{
        -: 1463:};
        -: 1464:
        -: 1465:template<class _Rp, class _A1, class _A2>
        -: 1466:struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
        -: 1467:    : public binary_function<_A1, _A2, _Rp>
        -: 1468:{
        -: 1469:};
        -: 1470:
        -: 1471:template <class _Fp>
        -: 1472:_LIBCPP_INLINE_VISIBILITY
        9: 1473:bool __not_null(_Fp const&) { return true; }
        -: 1474:
        -: 1475:template <class _Fp>
        -: 1476:_LIBCPP_INLINE_VISIBILITY
        -: 1477:bool __not_null(_Fp* __ptr) { return __ptr; }
        -: 1478:
        -: 1479:template <class _Ret, class _Class>
        -: 1480:_LIBCPP_INLINE_VISIBILITY
        -: 1481:bool __not_null(_Ret _Class::*__ptr) { return __ptr; }
        -: 1482:
        -: 1483:template <class _Fp>
        -: 1484:_LIBCPP_INLINE_VISIBILITY
        -: 1485:bool __not_null(function<_Fp> const& __f) { return !!__f; }
        -: 1486:
        -: 1487:#ifdef _LIBCPP_HAS_EXTENSION_BLOCKS
        -: 1488:template <class _Rp, class ..._Args>
        -: 1489:_LIBCPP_INLINE_VISIBILITY
        -: 1490:bool __not_null(_Rp (^__p)(_Args...)) { return __p; }
        -: 1491:#endif
        -: 1492:
        -: 1493:} // namespace __function
        -: 1494:
        -: 1495:#ifndef _LIBCPP_CXX03_LANG
        -: 1496:
        -: 1497:namespace __function {
        -: 1498:
        -: 1499:// __alloc_func holds a functor and an allocator.
        -: 1500:
        -: 1501:template <class _Fp, class _Ap, class _FB> class __alloc_func;
        -: 1502:template <class _Fp, class _FB>
        -: 1503:class __default_alloc_func;
        -: 1504:
        -: 1505:template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
    #####: 1506:class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>
        -: 1507:{
        -: 1508:    __compressed_pair<_Fp, _Ap> __f_;
        -: 1509:
        -: 1510:  public:
        -: 1511:    typedef _LIBCPP_NODEBUG_TYPE _Fp _Target;
        -: 1512:    typedef _LIBCPP_NODEBUG_TYPE _Ap _Alloc;
        -: 1513:
        -: 1514:    _LIBCPP_INLINE_VISIBILITY
       18: 1515:    const _Target& __target() const { return __f_.first(); }
        -: 1516:
        -: 1517:    // WIN32 APIs may define __allocator, so use __get_allocator instead.
        -: 1518:    _LIBCPP_INLINE_VISIBILITY
       18: 1519:    const _Alloc& __get_allocator() const { return __f_.second(); }
        -: 1520:
        -: 1521:    _LIBCPP_INLINE_VISIBILITY
        -: 1522:    explicit __alloc_func(_Target&& __f)
        -: 1523:        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
        -: 1524:               _VSTD::forward_as_tuple())
        -: 1525:    {
        -: 1526:    }
        -: 1527:
        -: 1528:    _LIBCPP_INLINE_VISIBILITY
       36: 1529:    explicit __alloc_func(const _Target& __f, const _Alloc& __a)
       36: 1530:        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
       18: 1531:               _VSTD::forward_as_tuple(__a))
       18: 1532:    {
       36: 1533:    }
        -: 1534:
        -: 1535:    _LIBCPP_INLINE_VISIBILITY
    #####: 1536:    explicit __alloc_func(const _Target& __f, _Alloc&& __a)
    #####: 1537:        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),
    #####: 1538:               _VSTD::forward_as_tuple(_VSTD::move(__a)))
    #####: 1539:    {
    #####: 1540:    }
        -: 1541:
        -: 1542:    _LIBCPP_INLINE_VISIBILITY
       18: 1543:    explicit __alloc_func(_Target&& __f, _Alloc&& __a)
       18: 1544:        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),
        9: 1545:               _VSTD::forward_as_tuple(_VSTD::move(__a)))
        9: 1546:    {
       18: 1547:    }
        -: 1548:
        -: 1549:    _LIBCPP_INLINE_VISIBILITY
        9: 1550:    _Rp operator()(_ArgTypes&&... __arg)
        -: 1551:    {
        -: 1552:        typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        9: 1553:        return _Invoker::__call(__f_.first(),
        -: 1554:                                _VSTD::forward<_ArgTypes>(__arg)...);
        -: 1555:    }
        -: 1556:
        -: 1557:    _LIBCPP_INLINE_VISIBILITY
        -: 1558:    __alloc_func* __clone() const
        -: 1559:    {
        -: 1560:        typedef allocator_traits<_Alloc> __alloc_traits;
        -: 1561:        typedef
        -: 1562:            typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
        -: 1563:                _AA;
        -: 1564:        _AA __a(__f_.second());
        -: 1565:        typedef __allocator_destructor<_AA> _Dp;
        -: 1566:        unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        -: 1567:        ::new ((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));
        -: 1568:        return __hold.release();
        -: 1569:    }
        -: 1570:
        -: 1571:    _LIBCPP_INLINE_VISIBILITY
       27: 1572:    void destroy() _NOEXCEPT { __f_.~__compressed_pair<_Target, _Alloc>(); }
        -: 1573:
        -: 1574:    static void __destroy_and_delete(__alloc_func* __f) {
        -: 1575:      typedef allocator_traits<_Alloc> __alloc_traits;
        -: 1576:      typedef typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
        -: 1577:          _FunAlloc;
        -: 1578:      _FunAlloc __a(__f->__get_allocator());
        -: 1579:      __f->destroy();
        -: 1580:      __a.deallocate(__f, 1);
        -: 1581:    }
        -: 1582:};
        -: 1583:
        -: 1584:template <class _Fp, class _Rp, class... _ArgTypes>
        -: 1585:class __default_alloc_func<_Fp, _Rp(_ArgTypes...)> {
        -: 1586:  _Fp __f_;
        -: 1587:
        -: 1588:public:
        -: 1589:  typedef _LIBCPP_NODEBUG_TYPE _Fp _Target;
        -: 1590:
        -: 1591:  _LIBCPP_INLINE_VISIBILITY
        -: 1592:  const _Target& __target() const { return __f_; }
        -: 1593:
        -: 1594:  _LIBCPP_INLINE_VISIBILITY
        -: 1595:  explicit __default_alloc_func(_Target&& __f) : __f_(std::move(__f)) {}
        -: 1596:
        -: 1597:  _LIBCPP_INLINE_VISIBILITY
        -: 1598:  explicit __default_alloc_func(const _Target& __f) : __f_(__f) {}
        -: 1599:
        -: 1600:  _LIBCPP_INLINE_VISIBILITY
        -: 1601:  _Rp operator()(_ArgTypes&&... __arg) {
        -: 1602:    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        -: 1603:    return _Invoker::__call(__f_, _VSTD::forward<_ArgTypes>(__arg)...);
        -: 1604:  }
        -: 1605:
        -: 1606:  _LIBCPP_INLINE_VISIBILITY
        -: 1607:  __default_alloc_func* __clone() const {
        -: 1608:      __builtin_new_allocator::__holder_t __hold =
        -: 1609:        __builtin_new_allocator::__allocate_type<__default_alloc_func>(1);
        -: 1610:    __default_alloc_func* __res =
        -: 1611:        ::new (__hold.get()) __default_alloc_func(__f_);
        -: 1612:    (void)__hold.release();
        -: 1613:    return __res;
        -: 1614:  }
        -: 1615:
        -: 1616:  _LIBCPP_INLINE_VISIBILITY
        -: 1617:  void destroy() _NOEXCEPT { __f_.~_Target(); }
        -: 1618:
        -: 1619:  static void __destroy_and_delete(__default_alloc_func* __f) {
        -: 1620:    __f->destroy();
        -: 1621:      __builtin_new_allocator::__deallocate_type<__default_alloc_func>(__f, 1);
        -: 1622:  }
        -: 1623:};
        -: 1624:
        -: 1625:// __base provides an abstract interface for copyable functors.
        -: 1626:
        -: 1627:template<class _Fp> class _LIBCPP_TEMPLATE_VIS __base;
        -: 1628:
        -: 1629:template<class _Rp, class ..._ArgTypes>
        -: 1630:class __base<_Rp(_ArgTypes...)>
        -: 1631:{
        -: 1632:    __base(const __base&);
        -: 1633:    __base& operator=(const __base&);
        -: 1634:public:
       27: 1635:    _LIBCPP_INLINE_VISIBILITY __base() {}
    #####: 1636:    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}
        -: 1637:    virtual __base* __clone() const = 0;
        -: 1638:    virtual void __clone(__base*) const = 0;
        -: 1639:    virtual void destroy() _NOEXCEPT = 0;
        -: 1640:    virtual void destroy_deallocate() _NOEXCEPT = 0;
        -: 1641:    virtual _Rp operator()(_ArgTypes&& ...) = 0;
        -: 1642:#ifndef _LIBCPP_NO_RTTI
        -: 1643:    virtual const void* target(const type_info&) const _NOEXCEPT = 0;
        -: 1644:    virtual const std::type_info& target_type() const _NOEXCEPT = 0;
        -: 1645:#endif  // _LIBCPP_NO_RTTI
        -: 1646:};
        -: 1647:
        -: 1648:// __func implements __base for a given functor type.
        -: 1649:
    #####: 1650:template<class _FD, class _Alloc, class _FB> class __func;
        -: 1651:
        -: 1652:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1653:class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
        -: 1654:    : public  __base<_Rp(_ArgTypes...)>
        -: 1655:{
        -: 1656:    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;
        -: 1657:public:
        -: 1658:    _LIBCPP_INLINE_VISIBILITY
        -: 1659:    explicit __func(_Fp&& __f)
        -: 1660:        : __f_(_VSTD::move(__f)) {}
        -: 1661:
        -: 1662:    _LIBCPP_INLINE_VISIBILITY
       36: 1663:    explicit __func(const _Fp& __f, const _Alloc& __a)
       54: 1664:        : __f_(__f, __a) {}
        -: 1665:
        -: 1666:    _LIBCPP_INLINE_VISIBILITY
    #####: 1667:    explicit __func(const _Fp& __f, _Alloc&& __a)
    #####: 1668:        : __f_(__f, _VSTD::move(__a)) {}
        -: 1669:
        -: 1670:    _LIBCPP_INLINE_VISIBILITY
       18: 1671:    explicit __func(_Fp&& __f, _Alloc&& __a)
       27: 1672:        : __f_(_VSTD::move(__f), _VSTD::move(__a)) {}
        -: 1673:
        -: 1674:    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
        -: 1675:    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
        -: 1676:    virtual void destroy() _NOEXCEPT;
        -: 1677:    virtual void destroy_deallocate() _NOEXCEPT;
        -: 1678:    virtual _Rp operator()(_ArgTypes&&... __arg);
        -: 1679:#ifndef _LIBCPP_NO_RTTI
        -: 1680:    virtual const void* target(const type_info&) const _NOEXCEPT;
        -: 1681:    virtual const std::type_info& target_type() const _NOEXCEPT;
        -: 1682:#endif  // _LIBCPP_NO_RTTI
        -: 1683:};
        -: 1684:
        -: 1685:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1686:__base<_Rp(_ArgTypes...)>*
    #####: 1687:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
        -: 1688:{
        -: 1689:    typedef allocator_traits<_Alloc> __alloc_traits;
        -: 1690:    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    #####: 1691:    _Ap __a(__f_.__get_allocator());
        -: 1692:    typedef __allocator_destructor<_Ap> _Dp;
    #####: 1693:    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    #####: 1694:    ::new ((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a));
    #####: 1695:    return __hold.release();
    #####: 1696:}
        -: 1697:
        -: 1698:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1699:void
       18: 1700:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
        -: 1701:{
       18: 1702:    ::new (__p) __func(__f_.__target(), __f_.__get_allocator());
       18: 1703:}
        -: 1704:
        -: 1705:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1706:void
       27: 1707:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT
        -: 1708:{
       27: 1709:    __f_.destroy();
       27: 1710:}
        -: 1711:
        -: 1712:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1713:void
    #####: 1714:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT
        -: 1715:{
        -: 1716:    typedef allocator_traits<_Alloc> __alloc_traits;
        -: 1717:    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    #####: 1718:    _Ap __a(__f_.__get_allocator());
    #####: 1719:    __f_.destroy();
    #####: 1720:    __a.deallocate(this, 1);
    #####: 1721:}
        -: 1722:
        -: 1723:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1724:_Rp
        9: 1725:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
        -: 1726:{
        9: 1727:    return __f_(_VSTD::forward<_ArgTypes>(__arg)...);
        -: 1728:}
        -: 1729:
        -: 1730:#ifndef _LIBCPP_NO_RTTI
        -: 1731:
        -: 1732:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1733:const void*
    #####: 1734:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT
        -: 1735:{
    #####: 1736:    if (__ti == typeid(_Fp))
    #####: 1737:        return &__f_.__target();
    #####: 1738:    return (const void*)0;
    #####: 1739:}
        -: 1740:
        -: 1741:template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 1742:const std::type_info&
    #####: 1743:__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
        -: 1744:{
    #####: 1745:    return typeid(_Fp);
        -: 1746:}
        -: 1747:
        -: 1748:#endif  // _LIBCPP_NO_RTTI
        -: 1749:
        -: 1750:// __value_func creates a value-type from a __func.
        -: 1751:
        -: 1752:template <class _Fp> class __value_func;
        -: 1753:
        -: 1754:template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>
        -: 1755:{
        -: 1756:    typename aligned_storage<3 * sizeof(void*)>::type __buf_;
        -: 1757:
        -: 1758:    typedef __base<_Rp(_ArgTypes...)> __func;
        -: 1759:    __func* __f_;
        -: 1760:
       18: 1761:    _LIBCPP_NO_CFI static __func* __as_base(void* p)
        -: 1762:    {
       18: 1763:        return reinterpret_cast<__func*>(p);
        -: 1764:    }
        -: 1765:
        -: 1766:  public:
        -: 1767:    _LIBCPP_INLINE_VISIBILITY
      108: 1768:    __value_func() _NOEXCEPT : __f_(0) {}
        -: 1769:
        -: 1770:    template <class _Fp, class _Alloc>
       18: 1771:    _LIBCPP_INLINE_VISIBILITY __value_func(_Fp&& __f, const _Alloc& __a)
        9: 1772:        : __f_(0)
        9: 1773:    {
        -: 1774:        typedef allocator_traits<_Alloc> __alloc_traits;
        -: 1775:        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        -: 1776:        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
        -: 1777:            _FunAlloc;
        -: 1778:
        9: 1779:        if (__function::__not_null(__f))
        -: 1780:        {
        9: 1781:            _FunAlloc __af(__a);
        -: 1782:            if (sizeof(_Fun) <= sizeof(__buf_) &&
        -: 1783:                is_nothrow_copy_constructible<_Fp>::value &&
        -: 1784:                is_nothrow_copy_constructible<_FunAlloc>::value)
        -: 1785:            {
        9: 1786:                __f_ =
        9: 1787:                    ::new ((void*)&__buf_) _Fun(_VSTD::move(__f), _Alloc(__af));
        -: 1788:            }
        -: 1789:            else
        -: 1790:            {
        -: 1791:                typedef __allocator_destructor<_FunAlloc> _Dp;
        -: 1792:                unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
        -: 1793:                ::new ((void*)__hold.get()) _Fun(_VSTD::move(__f), _Alloc(__a));
        -: 1794:                __f_ = __hold.release();
        -: 1795:            }
        9: 1796:        }
       18: 1797:    }
        -: 1798:
        -: 1799:    template <class _Fp,
        -: 1800:        class = typename enable_if<!is_same<typename decay<_Fp>::type, __value_func>::value>::type>
        9: 1801:    _LIBCPP_INLINE_VISIBILITY explicit __value_func(_Fp&& __f)
        9: 1802:        : __value_func(std::forward<_Fp>(__f), allocator<_Fp>()) {}
        -: 1803:
        -: 1804:    _LIBCPP_INLINE_VISIBILITY
       36: 1805:    __value_func(const __value_func& __f)
       18: 1806:    {
       18: 1807:        if (__f.__f_ == 0)
    #####: 1808:            __f_ = 0;
       18: 1809:        else if ((void*)__f.__f_ == &__f.__buf_)
        -: 1810:        {
       18: 1811:            __f_ = __as_base(&__buf_);
       18: 1812:            __f.__f_->__clone(__f_);
       18: 1813:        }
        -: 1814:        else
    #####: 1815:            __f_ = __f.__f_->__clone();
       36: 1816:    }
        -: 1817:
        -: 1818:    _LIBCPP_INLINE_VISIBILITY
        -: 1819:    __value_func(__value_func&& __f) _NOEXCEPT
        -: 1820:    {
        -: 1821:        if (__f.__f_ == 0)
        -: 1822:            __f_ = 0;
        -: 1823:        else if ((void*)__f.__f_ == &__f.__buf_)
        -: 1824:        {
        -: 1825:            __f_ = __as_base(&__buf_);
        -: 1826:            __f.__f_->__clone(__f_);
        -: 1827:        }
        -: 1828:        else
        -: 1829:        {
        -: 1830:            __f_ = __f.__f_;
        -: 1831:            __f.__f_ = 0;
        -: 1832:        }
        -: 1833:    }
        -: 1834:
        -: 1835:    _LIBCPP_INLINE_VISIBILITY
      162: 1836:    ~__value_func()
       81: 1837:    {
       81: 1838:        if ((void*)__f_ == &__buf_)
       27: 1839:            __f_->destroy();
       54: 1840:        else if (__f_)
    #####: 1841:            __f_->destroy_deallocate();
      162: 1842:    }
        -: 1843:
        -: 1844:    _LIBCPP_INLINE_VISIBILITY
        -: 1845:    __value_func& operator=(__value_func&& __f)
        -: 1846:    {
        -: 1847:        *this = nullptr;
        -: 1848:        if (__f.__f_ == 0)
        -: 1849:            __f_ = 0;
        -: 1850:        else if ((void*)__f.__f_ == &__f.__buf_)
        -: 1851:        {
        -: 1852:            __f_ = __as_base(&__buf_);
        -: 1853:            __f.__f_->__clone(__f_);
        -: 1854:        }
        -: 1855:        else
        -: 1856:        {
        -: 1857:            __f_ = __f.__f_;
        -: 1858:            __f.__f_ = 0;
        -: 1859:        }
        -: 1860:        return *this;
        -: 1861:    }
        -: 1862:
        -: 1863:    _LIBCPP_INLINE_VISIBILITY
        -: 1864:    __value_func& operator=(nullptr_t)
        -: 1865:    {
        -: 1866:        __func* __f = __f_;
        -: 1867:        __f_ = 0;
        -: 1868:        if ((void*)__f == &__buf_)
        -: 1869:            __f->destroy();
        -: 1870:        else if (__f)
        -: 1871:            __f->destroy_deallocate();
        -: 1872:        return *this;
        -: 1873:    }
        -: 1874:
        -: 1875:    _LIBCPP_INLINE_VISIBILITY
        9: 1876:    _Rp operator()(_ArgTypes&&... __args) const
        -: 1877:    {
        9: 1878:        if (__f_ == 0)
    #####: 1879:            __throw_bad_function_call();
        9: 1880:        return (*__f_)(_VSTD::forward<_ArgTypes>(__args)...);
        -: 1881:    }
        -: 1882:
        -: 1883:    _LIBCPP_INLINE_VISIBILITY
        -: 1884:    void swap(__value_func& __f) _NOEXCEPT
        -: 1885:    {
        -: 1886:        if (&__f == this)
        -: 1887:            return;
        -: 1888:        if ((void*)__f_ == &__buf_ && (void*)__f.__f_ == &__f.__buf_)
        -: 1889:        {
        -: 1890:            typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        -: 1891:            __func* __t = __as_base(&__tempbuf);
        -: 1892:            __f_->__clone(__t);
        -: 1893:            __f_->destroy();
        -: 1894:            __f_ = 0;
        -: 1895:            __f.__f_->__clone(__as_base(&__buf_));
        -: 1896:            __f.__f_->destroy();
        -: 1897:            __f.__f_ = 0;
        -: 1898:            __f_ = __as_base(&__buf_);
        -: 1899:            __t->__clone(__as_base(&__f.__buf_));
        -: 1900:            __t->destroy();
        -: 1901:            __f.__f_ = __as_base(&__f.__buf_);
        -: 1902:        }
        -: 1903:        else if ((void*)__f_ == &__buf_)
        -: 1904:        {
        -: 1905:            __f_->__clone(__as_base(&__f.__buf_));
        -: 1906:            __f_->destroy();
        -: 1907:            __f_ = __f.__f_;
        -: 1908:            __f.__f_ = __as_base(&__f.__buf_);
        -: 1909:        }
        -: 1910:        else if ((void*)__f.__f_ == &__f.__buf_)
        -: 1911:        {
        -: 1912:            __f.__f_->__clone(__as_base(&__buf_));
        -: 1913:            __f.__f_->destroy();
        -: 1914:            __f.__f_ = __f_;
        -: 1915:            __f_ = __as_base(&__buf_);
        -: 1916:        }
        -: 1917:        else
        -: 1918:            _VSTD::swap(__f_, __f.__f_);
        -: 1919:    }
        -: 1920:
        -: 1921:    _LIBCPP_INLINE_VISIBILITY
       63: 1922:    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT { return __f_ != 0; }
        -: 1923:
        -: 1924:#ifndef _LIBCPP_NO_RTTI
        -: 1925:    _LIBCPP_INLINE_VISIBILITY
        -: 1926:    const std::type_info& target_type() const _NOEXCEPT
        -: 1927:    {
        -: 1928:        if (__f_ == 0)
        -: 1929:            return typeid(void);
        -: 1930:        return __f_->target_type();
        -: 1931:    }
        -: 1932:
        -: 1933:    template <typename _Tp>
        -: 1934:    _LIBCPP_INLINE_VISIBILITY const _Tp* target() const _NOEXCEPT
        -: 1935:    {
        -: 1936:        if (__f_ == 0)
        -: 1937:            return 0;
        -: 1938:        return (const _Tp*)__f_->target(typeid(_Tp));
        -: 1939:    }
        -: 1940:#endif // _LIBCPP_NO_RTTI
        -: 1941:};
        -: 1942:
        -: 1943:// Storage for a functor object, to be used with __policy to manage copy and
        -: 1944:// destruction.
        -: 1945:union __policy_storage
        -: 1946:{
        -: 1947:    mutable char __small[sizeof(void*) * 2];
        -: 1948:    void* __large;
        -: 1949:};
        -: 1950:
        -: 1951:// True if _Fun can safely be held in __policy_storage.__small.
        -: 1952:template <typename _Fun>
        -: 1953:struct __use_small_storage
        -: 1954:    : public _VSTD::integral_constant<
        -: 1955:          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
        -: 1956:                    _LIBCPP_ALIGNOF(_Fun) <= _LIBCPP_ALIGNOF(__policy_storage) &&
        -: 1957:                    _VSTD::is_trivially_copy_constructible<_Fun>::value &&
        -: 1958:                    _VSTD::is_trivially_destructible<_Fun>::value> {};
        -: 1959:
        -: 1960:// Policy contains information about how to copy, destroy, and move the
        -: 1961:// underlying functor. You can think of it as a vtable of sorts.
        -: 1962:struct __policy
        -: 1963:{
        -: 1964:    // Used to copy or destroy __large values. null for trivial objects.
        -: 1965:    void* (*const __clone)(const void*);
        -: 1966:    void (*const __destroy)(void*);
        -: 1967:
        -: 1968:    // True if this is the null policy (no value).
        -: 1969:    const bool __is_null;
        -: 1970:
        -: 1971:    // The target type. May be null if RTTI is disabled.
        -: 1972:    const std::type_info* const __type_info;
        -: 1973:
        -: 1974:    // Returns a pointer to a static policy object suitable for the functor
        -: 1975:    // type.
        -: 1976:    template <typename _Fun>
        -: 1977:    _LIBCPP_INLINE_VISIBILITY static const __policy* __create()
        -: 1978:    {
        -: 1979:        return __choose_policy<_Fun>(__use_small_storage<_Fun>());
        -: 1980:    }
        -: 1981:
        -: 1982:    _LIBCPP_INLINE_VISIBILITY
        -: 1983:    static const __policy* __create_empty()
        -: 1984:    {
        -: 1985:        static const _LIBCPP_CONSTEXPR __policy __policy_ = {nullptr, nullptr,
        -: 1986:                                                             true,
        -: 1987:#ifndef _LIBCPP_NO_RTTI
        -: 1988:                                                             &typeid(void)
        -: 1989:#else
        -: 1990:                                                             nullptr
        -: 1991:#endif
        -: 1992:        };
        -: 1993:        return &__policy_;
        -: 1994:    }
        -: 1995:
        -: 1996:  private:
        -: 1997:    template <typename _Fun> static void* __large_clone(const void* __s)
        -: 1998:    {
        -: 1999:        const _Fun* __f = static_cast<const _Fun*>(__s);
        -: 2000:        return __f->__clone();
        -: 2001:    }
        -: 2002:
        -: 2003:    template <typename _Fun>
        -: 2004:    static void __large_destroy(void* __s) {
        -: 2005:      _Fun::__destroy_and_delete(static_cast<_Fun*>(__s));
        -: 2006:    }
        -: 2007:
        -: 2008:    template <typename _Fun>
        -: 2009:    _LIBCPP_INLINE_VISIBILITY static const __policy*
        -: 2010:    __choose_policy(/* is_small = */ false_type) {
        -: 2011:      static const _LIBCPP_CONSTEXPR __policy __policy_ = {
        -: 2012:          &__large_clone<_Fun>, &__large_destroy<_Fun>, false,
        -: 2013:#ifndef _LIBCPP_NO_RTTI
        -: 2014:          &typeid(typename _Fun::_Target)
        -: 2015:#else
        -: 2016:          nullptr
        -: 2017:#endif
        -: 2018:      };
        -: 2019:        return &__policy_;
        -: 2020:    }
        -: 2021:
        -: 2022:    template <typename _Fun>
        -: 2023:    _LIBCPP_INLINE_VISIBILITY static const __policy*
        -: 2024:        __choose_policy(/* is_small = */ true_type)
        -: 2025:    {
        -: 2026:        static const _LIBCPP_CONSTEXPR __policy __policy_ = {
        -: 2027:            nullptr, nullptr, false,
        -: 2028:#ifndef _LIBCPP_NO_RTTI
        -: 2029:            &typeid(typename _Fun::_Target)
        -: 2030:#else
        -: 2031:            nullptr
        -: 2032:#endif
        -: 2033:        };
        -: 2034:        return &__policy_;
        -: 2035:    }
        -: 2036:};
        -: 2037:
        -: 2038:// Used to choose between perfect forwarding or pass-by-value. Pass-by-value is
        -: 2039:// faster for types that can be passed in registers.
        -: 2040:template <typename _Tp>
        -: 2041:using __fast_forward =
        -: 2042:    typename _VSTD::conditional<_VSTD::is_scalar<_Tp>::value, _Tp, _Tp&&>::type;
        -: 2043:
        -: 2044:// __policy_invoker calls an instance of __alloc_func held in __policy_storage.
        -: 2045:
        -: 2046:template <class _Fp> struct __policy_invoker;
        -: 2047:
        -: 2048:template <class _Rp, class... _ArgTypes>
        -: 2049:struct __policy_invoker<_Rp(_ArgTypes...)>
        -: 2050:{
        -: 2051:    typedef _Rp (*__Call)(const __policy_storage*,
        -: 2052:                          __fast_forward<_ArgTypes>...);
        -: 2053:
        -: 2054:    __Call __call_;
        -: 2055:
        -: 2056:    // Creates an invoker that throws bad_function_call.
        -: 2057:    _LIBCPP_INLINE_VISIBILITY
        -: 2058:    __policy_invoker() : __call_(&__call_empty) {}
        -: 2059:
        -: 2060:    // Creates an invoker that calls the given instance of __func.
        -: 2061:    template <typename _Fun>
        -: 2062:    _LIBCPP_INLINE_VISIBILITY static __policy_invoker __create()
        -: 2063:    {
        -: 2064:        return __policy_invoker(&__call_impl<_Fun>);
        -: 2065:    }
        -: 2066:
        -: 2067:  private:
        -: 2068:    _LIBCPP_INLINE_VISIBILITY
        -: 2069:    explicit __policy_invoker(__Call __c) : __call_(__c) {}
        -: 2070:
        -: 2071:    static _Rp __call_empty(const __policy_storage*,
        -: 2072:                            __fast_forward<_ArgTypes>...)
        -: 2073:    {
        -: 2074:        __throw_bad_function_call();
        -: 2075:    }
        -: 2076:
        -: 2077:    template <typename _Fun>
        -: 2078:    static _Rp __call_impl(const __policy_storage* __buf,
        -: 2079:                           __fast_forward<_ArgTypes>... __args)
        -: 2080:    {
        -: 2081:        _Fun* __f = reinterpret_cast<_Fun*>(__use_small_storage<_Fun>::value
        -: 2082:                                                ? &__buf->__small
        -: 2083:                                                : __buf->__large);
        -: 2084:        return (*__f)(_VSTD::forward<_ArgTypes>(__args)...);
        -: 2085:    }
        -: 2086:};
        -: 2087:
        -: 2088:// __policy_func uses a __policy and __policy_invoker to create a type-erased,
        -: 2089:// copyable functor.
        -: 2090:
        -: 2091:template <class _Fp> class __policy_func;
        -: 2092:
        -: 2093:template <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>
        -: 2094:{
        -: 2095:    // Inline storage for small objects.
        -: 2096:    __policy_storage __buf_;
        -: 2097:
        -: 2098:    // Calls the value stored in __buf_. This could technically be part of
        -: 2099:    // policy, but storing it here eliminates a level of indirection inside
        -: 2100:    // operator().
        -: 2101:    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
        -: 2102:    __invoker __invoker_;
        -: 2103:
        -: 2104:    // The policy that describes how to move / copy / destroy __buf_. Never
        -: 2105:    // null, even if the function is empty.
        -: 2106:    const __policy* __policy_;
        -: 2107:
        -: 2108:  public:
        -: 2109:    _LIBCPP_INLINE_VISIBILITY
        -: 2110:    __policy_func() : __policy_(__policy::__create_empty()) {}
        -: 2111:
        -: 2112:    template <class _Fp, class _Alloc>
        -: 2113:    _LIBCPP_INLINE_VISIBILITY __policy_func(_Fp&& __f, const _Alloc& __a)
        -: 2114:        : __policy_(__policy::__create_empty())
        -: 2115:    {
        -: 2116:        typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        -: 2117:        typedef allocator_traits<_Alloc> __alloc_traits;
        -: 2118:        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
        -: 2119:            _FunAlloc;
        -: 2120:
        -: 2121:        if (__function::__not_null(__f))
        -: 2122:        {
        -: 2123:            __invoker_ = __invoker::template __create<_Fun>();
        -: 2124:            __policy_ = __policy::__create<_Fun>();
        -: 2125:
        -: 2126:            _FunAlloc __af(__a);
        -: 2127:            if (__use_small_storage<_Fun>())
        -: 2128:            {
        -: 2129:                ::new ((void*)&__buf_.__small)
        -: 2130:                    _Fun(_VSTD::move(__f), _Alloc(__af));
        -: 2131:            }
        -: 2132:            else
        -: 2133:            {
        -: 2134:                typedef __allocator_destructor<_FunAlloc> _Dp;
        -: 2135:                unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
        -: 2136:                ::new ((void*)__hold.get())
        -: 2137:                    _Fun(_VSTD::move(__f), _Alloc(__af));
        -: 2138:                __buf_.__large = __hold.release();
        -: 2139:            }
        -: 2140:        }
        -: 2141:    }
        -: 2142:
        -: 2143:    template <class _Fp, class = typename enable_if<!is_same<typename decay<_Fp>::type, __policy_func>::value>::type>
        -: 2144:    _LIBCPP_INLINE_VISIBILITY explicit __policy_func(_Fp&& __f)
        -: 2145:        : __policy_(__policy::__create_empty()) {
        -: 2146:      typedef __default_alloc_func<_Fp, _Rp(_ArgTypes...)> _Fun;
        -: 2147:
        -: 2148:      if (__function::__not_null(__f)) {
        -: 2149:        __invoker_ = __invoker::template __create<_Fun>();
        -: 2150:        __policy_ = __policy::__create<_Fun>();
        -: 2151:        if (__use_small_storage<_Fun>()) {
        -: 2152:          ::new ((void*)&__buf_.__small) _Fun(_VSTD::move(__f));
        -: 2153:        } else {
        -: 2154:          __builtin_new_allocator::__holder_t __hold =
        -: 2155:              __builtin_new_allocator::__allocate_type<_Fun>(1);
        -: 2156:          __buf_.__large = ::new (__hold.get()) _Fun(_VSTD::move(__f));
        -: 2157:          (void)__hold.release();
        -: 2158:        }
        -: 2159:      }
        -: 2160:    }
        -: 2161:
        -: 2162:    _LIBCPP_INLINE_VISIBILITY
        -: 2163:    __policy_func(const __policy_func& __f)
        -: 2164:        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
        -: 2165:          __policy_(__f.__policy_)
        -: 2166:    {
        -: 2167:        if (__policy_->__clone)
        -: 2168:            __buf_.__large = __policy_->__clone(__f.__buf_.__large);
        -: 2169:    }
        -: 2170:
        -: 2171:    _LIBCPP_INLINE_VISIBILITY
        -: 2172:    __policy_func(__policy_func&& __f)
        -: 2173:        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
        -: 2174:          __policy_(__f.__policy_)
        -: 2175:    {
        -: 2176:        if (__policy_->__destroy)
        -: 2177:        {
        -: 2178:            __f.__policy_ = __policy::__create_empty();
        -: 2179:            __f.__invoker_ = __invoker();
        -: 2180:        }
        -: 2181:    }
        -: 2182:
        -: 2183:    _LIBCPP_INLINE_VISIBILITY
        -: 2184:    ~__policy_func()
        -: 2185:    {
        -: 2186:        if (__policy_->__destroy)
        -: 2187:            __policy_->__destroy(__buf_.__large);
        -: 2188:    }
        -: 2189:
        -: 2190:    _LIBCPP_INLINE_VISIBILITY
        -: 2191:    __policy_func& operator=(__policy_func&& __f)
        -: 2192:    {
        -: 2193:        *this = nullptr;
        -: 2194:        __buf_ = __f.__buf_;
        -: 2195:        __invoker_ = __f.__invoker_;
        -: 2196:        __policy_ = __f.__policy_;
        -: 2197:        __f.__policy_ = __policy::__create_empty();
        -: 2198:        __f.__invoker_ = __invoker();
        -: 2199:        return *this;
        -: 2200:    }
        -: 2201:
        -: 2202:    _LIBCPP_INLINE_VISIBILITY
        -: 2203:    __policy_func& operator=(nullptr_t)
        -: 2204:    {
        -: 2205:        const __policy* __p = __policy_;
        -: 2206:        __policy_ = __policy::__create_empty();
        -: 2207:        __invoker_ = __invoker();
        -: 2208:        if (__p->__destroy)
        -: 2209:            __p->__destroy(__buf_.__large);
        -: 2210:        return *this;
        -: 2211:    }
        -: 2212:
        -: 2213:    _LIBCPP_INLINE_VISIBILITY
        -: 2214:    _Rp operator()(_ArgTypes&&... __args) const
        -: 2215:    {
        -: 2216:        return __invoker_.__call_(_VSTD::addressof(__buf_),
        -: 2217:                                  _VSTD::forward<_ArgTypes>(__args)...);
        -: 2218:    }
        -: 2219:
        -: 2220:    _LIBCPP_INLINE_VISIBILITY
        -: 2221:    void swap(__policy_func& __f)
        -: 2222:    {
        -: 2223:        _VSTD::swap(__invoker_, __f.__invoker_);
        -: 2224:        _VSTD::swap(__policy_, __f.__policy_);
        -: 2225:        _VSTD::swap(__buf_, __f.__buf_);
        -: 2226:    }
        -: 2227:
        -: 2228:    _LIBCPP_INLINE_VISIBILITY
        -: 2229:    explicit operator bool() const _NOEXCEPT
        -: 2230:    {
        -: 2231:        return !__policy_->__is_null;
        -: 2232:    }
        -: 2233:
        -: 2234:#ifndef _LIBCPP_NO_RTTI
        -: 2235:    _LIBCPP_INLINE_VISIBILITY
        -: 2236:    const std::type_info& target_type() const _NOEXCEPT
        -: 2237:    {
        -: 2238:        return *__policy_->__type_info;
        -: 2239:    }
        -: 2240:
        -: 2241:    template <typename _Tp>
        -: 2242:    _LIBCPP_INLINE_VISIBILITY const _Tp* target() const _NOEXCEPT
        -: 2243:    {
        -: 2244:        if (__policy_->__is_null || typeid(_Tp) != *__policy_->__type_info)
        -: 2245:            return nullptr;
        -: 2246:        if (__policy_->__clone) // Out of line storage.
        -: 2247:            return reinterpret_cast<const _Tp*>(__buf_.__large);
        -: 2248:        else
        -: 2249:            return reinterpret_cast<const _Tp*>(&__buf_.__small);
        -: 2250:    }
        -: 2251:#endif // _LIBCPP_NO_RTTI
        -: 2252:};
        -: 2253:
        -: 2254:#if defined(_LIBCPP_HAS_BLOCKS_RUNTIME) && !defined(_LIBCPP_HAS_OBJC_ARC)
        -: 2255:
        -: 2256:extern "C" void *_Block_copy(const void *);
        -: 2257:extern "C" void _Block_release(const void *);
        -: 2258:
        -: 2259:template<class _Rp1, class ..._ArgTypes1, class _Alloc, class _Rp, class ..._ArgTypes>
        -: 2260:class __func<_Rp1(^)(_ArgTypes1...), _Alloc, _Rp(_ArgTypes...)>
        -: 2261:    : public  __base<_Rp(_ArgTypes...)>
        -: 2262:{
        -: 2263:    typedef _Rp1(^__block_type)(_ArgTypes1...);
        -: 2264:    __block_type __f_;
        -: 2265:
        -: 2266:public:
        -: 2267:    _LIBCPP_INLINE_VISIBILITY
        -: 2268:    explicit __func(__block_type const& __f)
        -: 2269:        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
        -: 2270:    { }
        -: 2271:
        -: 2272:    // [TODO] add && to save on a retain
        -: 2273:
        -: 2274:    _LIBCPP_INLINE_VISIBILITY
        -: 2275:    explicit __func(__block_type __f, const _Alloc& /* unused */)
        -: 2276:        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
        -: 2277:    { }
        -: 2278:
        -: 2279:    virtual __base<_Rp(_ArgTypes...)>* __clone() const {
        -: 2280:        _LIBCPP_ASSERT(false,
        -: 2281:            "Block pointers are just pointers, so they should always fit into "
        -: 2282:            "std::function's small buffer optimization. This function should "
        -: 2283:            "never be invoked.");
        -: 2284:        return nullptr;
        -: 2285:    }
        -: 2286:
        -: 2287:    virtual void __clone(__base<_Rp(_ArgTypes...)>* __p) const {
        -: 2288:        ::new (__p) __func(__f_);
        -: 2289:    }
        -: 2290:
        -: 2291:    virtual void destroy() _NOEXCEPT {
        -: 2292:        if (__f_)
        -: 2293:            _Block_release(__f_);
        -: 2294:        __f_ = 0;
        -: 2295:    }
        -: 2296:
        -: 2297:    virtual void destroy_deallocate() _NOEXCEPT {
        -: 2298:        _LIBCPP_ASSERT(false,
        -: 2299:            "Block pointers are just pointers, so they should always fit into "
        -: 2300:            "std::function's small buffer optimization. This function should "
        -: 2301:            "never be invoked.");
        -: 2302:    }
        -: 2303:
        -: 2304:    virtual _Rp operator()(_ArgTypes&& ... __arg) {
        -: 2305:        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__arg)...);
        -: 2306:    }
        -: 2307:
        -: 2308:#ifndef _LIBCPP_NO_RTTI
        -: 2309:    virtual const void* target(type_info const& __ti) const _NOEXCEPT {
        -: 2310:        if (__ti == typeid(__func::__block_type))
        -: 2311:            return &__f_;
        -: 2312:        return (const void*)nullptr;
        -: 2313:    }
        -: 2314:
        -: 2315:    virtual const std::type_info& target_type() const _NOEXCEPT {
        -: 2316:        return typeid(__func::__block_type);
        -: 2317:    }
        -: 2318:#endif  // _LIBCPP_NO_RTTI
        -: 2319:};
        -: 2320:
        -: 2321:#endif  // _LIBCPP_HAS_EXTENSION_BLOCKS && !_LIBCPP_HAS_OBJC_ARC
        -: 2322:
        -: 2323:}  // __function
        -: 2324:
        -: 2325:template<class _Rp, class ..._ArgTypes>
        -: 2326:class _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>
        -: 2327:    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
        -: 2328:      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
        -: 2329:{
        -: 2330:#ifndef _LIBCPP_ABI_OPTIMIZED_FUNCTION
        -: 2331:    typedef __function::__value_func<_Rp(_ArgTypes...)> __func;
        -: 2332:#else
        -: 2333:    typedef __function::__policy_func<_Rp(_ArgTypes...)> __func;
        -: 2334:#endif
        -: 2335:
        -: 2336:    __func __f_;
        -: 2337:
        -: 2338:    template <class _Fp, bool = _And<
        -: 2339:        _IsNotSame<__uncvref_t<_Fp>, function>,
        -: 2340:        __invokable<_Fp, _ArgTypes...>
        -: 2341:    >::value>
        -: 2342:    struct __callable;
        -: 2343:    template <class _Fp>
        -: 2344:        struct __callable<_Fp, true>
        -: 2345:        {
        -: 2346:            static const bool value = is_same<void, _Rp>::value ||
        -: 2347:                is_convertible<typename __invoke_of<_Fp, _ArgTypes...>::type,
        -: 2348:                               _Rp>::value;
        -: 2349:        };
        -: 2350:    template <class _Fp>
        -: 2351:        struct __callable<_Fp, false>
        -: 2352:        {
        -: 2353:            static const bool value = false;
        -: 2354:        };
        -: 2355:
        -: 2356:  template <class _Fp>
        -: 2357:  using _EnableIfLValueCallable = typename enable_if<__callable<_Fp&>::value>::type;
        -: 2358:public:
        -: 2359:    typedef _Rp result_type;
        -: 2360:
        -: 2361:    // construct/copy/destroy:
        -: 2362:    _LIBCPP_INLINE_VISIBILITY
      108: 2363:    function() _NOEXCEPT { }
        -: 2364:    _LIBCPP_INLINE_VISIBILITY
        -: 2365:    function(nullptr_t) _NOEXCEPT {}
        -: 2366:    function(const function&);
        -: 2367:    function(function&&) _NOEXCEPT;
        -: 2368:    template<class _Fp, class = _EnableIfLValueCallable<_Fp>>
        -: 2369:    function(_Fp);
        -: 2370:
        -: 2371:#if _LIBCPP_STD_VER <= 14
        -: 2372:    template<class _Alloc>
        -: 2373:      _LIBCPP_INLINE_VISIBILITY
        -: 2374:      function(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
        -: 2375:    template<class _Alloc>
        -: 2376:      _LIBCPP_INLINE_VISIBILITY
        -: 2377:      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT {}
        -: 2378:    template<class _Alloc>
        -: 2379:      function(allocator_arg_t, const _Alloc&, const function&);
        -: 2380:    template<class _Alloc>
        -: 2381:      function(allocator_arg_t, const _Alloc&, function&&);
        -: 2382:    template<class _Fp, class _Alloc, class = _EnableIfLValueCallable<_Fp>>
        -: 2383:      function(allocator_arg_t, const _Alloc& __a, _Fp __f);
        -: 2384:#endif
        -: 2385:
        -: 2386:    function& operator=(const function&);
        -: 2387:    function& operator=(function&&) _NOEXCEPT;
        -: 2388:    function& operator=(nullptr_t) _NOEXCEPT;
        -: 2389:    template<class _Fp, class = _EnableIfLValueCallable<typename decay<_Fp>::type>>
        -: 2390:    function& operator=(_Fp&&);
        -: 2391:
        -: 2392:    ~function();
        -: 2393:
        -: 2394:    // function modifiers:
        -: 2395:    void swap(function&) _NOEXCEPT;
        -: 2396:
        -: 2397:#if _LIBCPP_STD_VER <= 14
        -: 2398:    template<class _Fp, class _Alloc>
        -: 2399:      _LIBCPP_INLINE_VISIBILITY
        -: 2400:      void assign(_Fp&& __f, const _Alloc& __a)
        -: 2401:        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}
        -: 2402:#endif
        -: 2403:
        -: 2404:    // function capacity:
        -: 2405:    _LIBCPP_INLINE_VISIBILITY
       63: 2406:    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
       63: 2407:      return static_cast<bool>(__f_);
        -: 2408:    }
        -: 2409:
        -: 2410:    // deleted overloads close possible hole in the type system
        -: 2411:    template<class _R2, class... _ArgTypes2>
        -: 2412:      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
        -: 2413:    template<class _R2, class... _ArgTypes2>
        -: 2414:      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
        -: 2415:public:
        -: 2416:    // function invocation:
        -: 2417:    _Rp operator()(_ArgTypes...) const;
        -: 2418:
        -: 2419:#ifndef _LIBCPP_NO_RTTI
        -: 2420:    // function target access:
        -: 2421:    const std::type_info& target_type() const _NOEXCEPT;
        -: 2422:    template <typename _Tp> _Tp* target() _NOEXCEPT;
        -: 2423:    template <typename _Tp> const _Tp* target() const _NOEXCEPT;
        -: 2424:#endif  // _LIBCPP_NO_RTTI
        -: 2425:};
        -: 2426:
        -: 2427:#ifndef _LIBCPP_HAS_NO_DEDUCTION_GUIDES
        -: 2428:template<class _Rp, class ..._Ap>
        -: 2429:function(_Rp(*)(_Ap...)) -> function<_Rp(_Ap...)>;
        -: 2430:
        -: 2431:template<class _Fp>
        -: 2432:struct __strip_signature;
        -: 2433:
        -: 2434:template<class _Rp, class _Gp, class ..._Ap>
        -: 2435:struct __strip_signature<_Rp (_Gp::*) (_Ap...)> { using type = _Rp(_Ap...); };
        -: 2436:template<class _Rp, class _Gp, class ..._Ap>
        -: 2437:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const> { using type = _Rp(_Ap...); };
        -: 2438:template<class _Rp, class _Gp, class ..._Ap>
        -: 2439:struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile> { using type = _Rp(_Ap...); };
        -: 2440:template<class _Rp, class _Gp, class ..._Ap>
        -: 2441:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile> { using type = _Rp(_Ap...); };
        -: 2442:
        -: 2443:template<class _Rp, class _Gp, class ..._Ap>
        -: 2444:struct __strip_signature<_Rp (_Gp::*) (_Ap...) &> { using type = _Rp(_Ap...); };
        -: 2445:template<class _Rp, class _Gp, class ..._Ap>
        -: 2446:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const &> { using type = _Rp(_Ap...); };
        -: 2447:template<class _Rp, class _Gp, class ..._Ap>
        -: 2448:struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile &> { using type = _Rp(_Ap...); };
        -: 2449:template<class _Rp, class _Gp, class ..._Ap>
        -: 2450:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile &> { using type = _Rp(_Ap...); };
        -: 2451:
        -: 2452:template<class _Rp, class _Gp, class ..._Ap>
        -: 2453:struct __strip_signature<_Rp (_Gp::*) (_Ap...) noexcept> { using type = _Rp(_Ap...); };
        -: 2454:template<class _Rp, class _Gp, class ..._Ap>
        -: 2455:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const noexcept> { using type = _Rp(_Ap...); };
        -: 2456:template<class _Rp, class _Gp, class ..._Ap>
        -: 2457:struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile noexcept> { using type = _Rp(_Ap...); };
        -: 2458:template<class _Rp, class _Gp, class ..._Ap>
        -: 2459:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile noexcept> { using type = _Rp(_Ap...); };
        -: 2460:
        -: 2461:template<class _Rp, class _Gp, class ..._Ap>
        -: 2462:struct __strip_signature<_Rp (_Gp::*) (_Ap...) & noexcept> { using type = _Rp(_Ap...); };
        -: 2463:template<class _Rp, class _Gp, class ..._Ap>
        -: 2464:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const & noexcept> { using type = _Rp(_Ap...); };
        -: 2465:template<class _Rp, class _Gp, class ..._Ap>
        -: 2466:struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile & noexcept> { using type = _Rp(_Ap...); };
        -: 2467:template<class _Rp, class _Gp, class ..._Ap>
        -: 2468:struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile & noexcept> { using type = _Rp(_Ap...); };
        -: 2469:
        -: 2470:template<class _Fp, class _Stripped = typename __strip_signature<decltype(&_Fp::operator())>::type>
        -: 2471:function(_Fp) -> function<_Stripped>;
        -: 2472:#endif // !_LIBCPP_HAS_NO_DEDUCTION_GUIDES
        -: 2473:
        -: 2474:template<class _Rp, class ..._ArgTypes>
       36: 2475:function<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}
        -: 2476:
        -: 2477:#if _LIBCPP_STD_VER <= 14
        -: 2478:template<class _Rp, class ..._ArgTypes>
        -: 2479:template <class _Alloc>
        -: 2480:function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
        -: 2481:                                     const function& __f) : __f_(__f.__f_) {}
        -: 2482:#endif
        -: 2483:
        -: 2484:template <class _Rp, class... _ArgTypes>
        -: 2485:function<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT
        -: 2486:    : __f_(_VSTD::move(__f.__f_)) {}
        -: 2487:
        -: 2488:#if _LIBCPP_STD_VER <= 14
        -: 2489:template<class _Rp, class ..._ArgTypes>
        -: 2490:template <class _Alloc>
        -: 2491:function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
        -: 2492:                                      function&& __f)
        -: 2493:    : __f_(_VSTD::move(__f.__f_)) {}
        -: 2494:#endif
        -: 2495:
        -: 2496:template <class _Rp, class... _ArgTypes>
        -: 2497:template <class _Fp, class>
       18: 2498:function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(_VSTD::move(__f)) {}
        -: 2499:
        -: 2500:#if _LIBCPP_STD_VER <= 14
        -: 2501:template <class _Rp, class... _ArgTypes>
        -: 2502:template <class _Fp, class _Alloc, class>
        -: 2503:function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a,
        -: 2504:                                      _Fp __f)
        -: 2505:    : __f_(_VSTD::move(__f), __a) {}
        -: 2506:#endif
        -: 2507:
        -: 2508:template<class _Rp, class ..._ArgTypes>
        -: 2509:function<_Rp(_ArgTypes...)>&
        -: 2510:function<_Rp(_ArgTypes...)>::operator=(const function& __f)
        -: 2511:{
        -: 2512:    function(__f).swap(*this);
        -: 2513:    return *this;
        -: 2514:}
        -: 2515:
        -: 2516:template<class _Rp, class ..._ArgTypes>
        -: 2517:function<_Rp(_ArgTypes...)>&
        -: 2518:function<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT
        -: 2519:{
        -: 2520:    __f_ = std::move(__f.__f_);
        -: 2521:    return *this;
        -: 2522:}
        -: 2523:
        -: 2524:template<class _Rp, class ..._ArgTypes>
        -: 2525:function<_Rp(_ArgTypes...)>&
        -: 2526:function<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT
        -: 2527:{
        -: 2528:    __f_ = nullptr;
        -: 2529:    return *this;
        -: 2530:}
        -: 2531:
        -: 2532:template<class _Rp, class ..._ArgTypes>
        -: 2533:template <class _Fp, class>
        -: 2534:function<_Rp(_ArgTypes...)>&
        -: 2535:function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
        -: 2536:{
        -: 2537:    function(_VSTD::forward<_Fp>(__f)).swap(*this);
        -: 2538:    return *this;
        -: 2539:}
        -: 2540:
        -: 2541:template<class _Rp, class ..._ArgTypes>
      162: 2542:function<_Rp(_ArgTypes...)>::~function() {}
        -: 2543:
        -: 2544:template<class _Rp, class ..._ArgTypes>
        -: 2545:void
        -: 2546:function<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT
        -: 2547:{
        -: 2548:    __f_.swap(__f.__f_);
        -: 2549:}
        -: 2550:
        -: 2551:template<class _Rp, class ..._ArgTypes>
        -: 2552:_Rp
        9: 2553:function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
        -: 2554:{
        9: 2555:    return __f_(_VSTD::forward<_ArgTypes>(__arg)...);
        -: 2556:}
        -: 2557:
        -: 2558:#ifndef _LIBCPP_NO_RTTI
        -: 2559:
        -: 2560:template<class _Rp, class ..._ArgTypes>
        -: 2561:const std::type_info&
        -: 2562:function<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT
        -: 2563:{
        -: 2564:    return __f_.target_type();
        -: 2565:}
        -: 2566:
        -: 2567:template<class _Rp, class ..._ArgTypes>
        -: 2568:template <typename _Tp>
        -: 2569:_Tp*
        -: 2570:function<_Rp(_ArgTypes...)>::target() _NOEXCEPT
        -: 2571:{
        -: 2572:    return (_Tp*)(__f_.template target<_Tp>());
        -: 2573:}
        -: 2574:
        -: 2575:template<class _Rp, class ..._ArgTypes>
        -: 2576:template <typename _Tp>
        -: 2577:const _Tp*
        -: 2578:function<_Rp(_ArgTypes...)>::target() const _NOEXCEPT
        -: 2579:{
        -: 2580:    return __f_.template target<_Tp>();
        -: 2581:}
        -: 2582:
        -: 2583:#endif  // _LIBCPP_NO_RTTI
        -: 2584:
        -: 2585:template <class _Rp, class... _ArgTypes>
        -: 2586:inline _LIBCPP_INLINE_VISIBILITY
        -: 2587:bool
       63: 2588:operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}
        -: 2589:
        -: 2590:template <class _Rp, class... _ArgTypes>
        -: 2591:inline _LIBCPP_INLINE_VISIBILITY
        -: 2592:bool
        -: 2593:operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}
        -: 2594:
        -: 2595:template <class _Rp, class... _ArgTypes>
        -: 2596:inline _LIBCPP_INLINE_VISIBILITY
        -: 2597:bool
        -: 2598:operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}
        -: 2599:
        -: 2600:template <class _Rp, class... _ArgTypes>
        -: 2601:inline _LIBCPP_INLINE_VISIBILITY
        -: 2602:bool
        -: 2603:operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}
        -: 2604:
        -: 2605:template <class _Rp, class... _ArgTypes>
        -: 2606:inline _LIBCPP_INLINE_VISIBILITY
        -: 2607:void
        -: 2608:swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT
        -: 2609:{return __x.swap(__y);}
        -: 2610:
        -: 2611:#else // _LIBCPP_CXX03_LANG
        -: 2612:
        -: 2613:#include <__functional_03>
        -: 2614:
        -: 2615:#endif
        -: 2616:
        -: 2617:////////////////////////////////////////////////////////////////////////////////
        -: 2618://                                  BIND
        -: 2619://==============================================================================
        -: 2620:
        -: 2621:template<class _Tp> struct __is_bind_expression : public false_type {};
        -: 2622:template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression
        -: 2623:    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};
        -: 2624:
        -: 2625:#if _LIBCPP_STD_VER > 14
        -: 2626:template <class _Tp>
        -: 2627:_LIBCPP_INLINE_VAR constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;
        -: 2628:#endif
        -: 2629:
        -: 2630:template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
        -: 2631:template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder
        -: 2632:    : public __is_placeholder<typename remove_cv<_Tp>::type> {};
        -: 2633:
        -: 2634:#if _LIBCPP_STD_VER > 14
        -: 2635:template <class _Tp>
        -: 2636:_LIBCPP_INLINE_VAR constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;
        -: 2637:#endif
        -: 2638:
        -: 2639:namespace placeholders
        -: 2640:{
        -: 2641:
        -: 2642:template <int _Np> struct __ph {};
        -: 2643:
        -: 2644:#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)
        -: 2645:_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
        -: 2646:_LIBCPP_FUNC_VIS extern const __ph<2>   _2;
        -: 2647:_LIBCPP_FUNC_VIS extern const __ph<3>   _3;
        -: 2648:_LIBCPP_FUNC_VIS extern const __ph<4>   _4;
        -: 2649:_LIBCPP_FUNC_VIS extern const __ph<5>   _5;
        -: 2650:_LIBCPP_FUNC_VIS extern const __ph<6>   _6;
        -: 2651:_LIBCPP_FUNC_VIS extern const __ph<7>   _7;
        -: 2652:_LIBCPP_FUNC_VIS extern const __ph<8>   _8;
        -: 2653:_LIBCPP_FUNC_VIS extern const __ph<9>   _9;
        -: 2654:_LIBCPP_FUNC_VIS extern const __ph<10> _10;
        -: 2655:#else
        -: 2656:/* _LIBCPP_INLINE_VAR */ constexpr __ph<1>   _1{};
        -: 2657:/* _LIBCPP_INLINE_VAR */ constexpr __ph<2>   _2{};
        -: 2658:/* _LIBCPP_INLINE_VAR */ constexpr __ph<3>   _3{};
        -: 2659:/* _LIBCPP_INLINE_VAR */ constexpr __ph<4>   _4{};
        -: 2660:/* _LIBCPP_INLINE_VAR */ constexpr __ph<5>   _5{};
        -: 2661:/* _LIBCPP_INLINE_VAR */ constexpr __ph<6>   _6{};
        -: 2662:/* _LIBCPP_INLINE_VAR */ constexpr __ph<7>   _7{};
        -: 2663:/* _LIBCPP_INLINE_VAR */ constexpr __ph<8>   _8{};
        -: 2664:/* _LIBCPP_INLINE_VAR */ constexpr __ph<9>   _9{};
        -: 2665:/* _LIBCPP_INLINE_VAR */ constexpr __ph<10> _10{};
        -: 2666:#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)
        -: 2667:
        -: 2668:}  // placeholders
        -: 2669:
        -: 2670:template<int _Np>
        -: 2671:struct __is_placeholder<placeholders::__ph<_Np> >
        -: 2672:    : public integral_constant<int, _Np> {};
        -: 2673:
        -: 2674:
        -: 2675:#ifndef _LIBCPP_CXX03_LANG
        -: 2676:
        -: 2677:template <class _Tp, class _Uj>
        -: 2678:inline _LIBCPP_INLINE_VISIBILITY
        -: 2679:_Tp&
        -: 2680:__mu(reference_wrapper<_Tp> __t, _Uj&)
        -: 2681:{
        -: 2682:    return __t.get();
        -: 2683:}
        -: 2684:
        -: 2685:template <class _Ti, class ..._Uj, size_t ..._Indx>
        -: 2686:inline _LIBCPP_INLINE_VISIBILITY
        -: 2687:typename __invoke_of<_Ti&, _Uj...>::type
        -: 2688:__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
        -: 2689:{
        -: 2690:    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);
        -: 2691:}
        -: 2692:
        -: 2693:template <class _Ti, class ..._Uj>
        -: 2694:inline _LIBCPP_INLINE_VISIBILITY
        -: 2695:typename _EnableIf
        -: 2696:<
        -: 2697:    is_bind_expression<_Ti>::value,
        -: 2698:    __invoke_of<_Ti&, _Uj...>
        -: 2699:>::type
        -: 2700:__mu(_Ti& __ti, tuple<_Uj...>& __uj)
        -: 2701:{
        -: 2702:    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
        -: 2703:    return  __mu_expand(__ti, __uj, __indices());
        -: 2704:}
        -: 2705:
        -: 2706:template <bool IsPh, class _Ti, class _Uj>
        -: 2707:struct __mu_return2 {};
        -: 2708:
        -: 2709:template <class _Ti, class _Uj>
        -: 2710:struct __mu_return2<true, _Ti, _Uj>
        -: 2711:{
        -: 2712:    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
        -: 2713:};
        -: 2714:
        -: 2715:template <class _Ti, class _Uj>
        -: 2716:inline _LIBCPP_INLINE_VISIBILITY
        -: 2717:typename enable_if
        -: 2718:<
        -: 2719:    0 < is_placeholder<_Ti>::value,
        -: 2720:    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
        -: 2721:>::type
        -: 2722:__mu(_Ti&, _Uj& __uj)
        -: 2723:{
        -: 2724:    const size_t _Indx = is_placeholder<_Ti>::value - 1;
        -: 2725:    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));
        -: 2726:}
        -: 2727:
        -: 2728:template <class _Ti, class _Uj>
        -: 2729:inline _LIBCPP_INLINE_VISIBILITY
        -: 2730:typename enable_if
        -: 2731:<
        -: 2732:    !is_bind_expression<_Ti>::value &&
        -: 2733:    is_placeholder<_Ti>::value == 0 &&
        -: 2734:    !__is_reference_wrapper<_Ti>::value,
        -: 2735:    _Ti&
        -: 2736:>::type
        -: 2737:__mu(_Ti& __ti, _Uj&)
        -: 2738:{
        -: 2739:    return __ti;
        -: 2740:}
        -: 2741:
        -: 2742:template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
        -: 2743:          class _TupleUj>
        -: 2744:struct __mu_return_impl;
        -: 2745:
        -: 2746:template <bool _Invokable, class _Ti, class ..._Uj>
        -: 2747:struct __mu_return_invokable  // false
        -: 2748:{
        -: 2749:    typedef __nat type;
        -: 2750:};
        -: 2751:
        -: 2752:template <class _Ti, class ..._Uj>
        -: 2753:struct __mu_return_invokable<true, _Ti, _Uj...>
        -: 2754:{
        -: 2755:    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
        -: 2756:};
        -: 2757:
        -: 2758:template <class _Ti, class ..._Uj>
        -: 2759:struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
        -: 2760:    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
        -: 2761:{
        -: 2762:};
        -: 2763:
        -: 2764:template <class _Ti, class _TupleUj>
        -: 2765:struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
        -: 2766:{
        -: 2767:    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
        -: 2768:                                   _TupleUj>::type&& type;
        -: 2769:};
        -: 2770:
        -: 2771:template <class _Ti, class _TupleUj>
        -: 2772:struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
        -: 2773:{
        -: 2774:    typedef typename _Ti::type& type;
        -: 2775:};
        -: 2776:
        -: 2777:template <class _Ti, class _TupleUj>
        -: 2778:struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
        -: 2779:{
        -: 2780:    typedef _Ti& type;
        -: 2781:};
        -: 2782:
        -: 2783:template <class _Ti, class _TupleUj>
        -: 2784:struct __mu_return
        -: 2785:    : public __mu_return_impl<_Ti,
        -: 2786:                              __is_reference_wrapper<_Ti>::value,
        -: 2787:                              is_bind_expression<_Ti>::value,
        -: 2788:                              0 < is_placeholder<_Ti>::value &&
        -: 2789:                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
        -: 2790:                              _TupleUj>
        -: 2791:{
        -: 2792:};
        -: 2793:
        -: 2794:template <class _Fp, class _BoundArgs, class _TupleUj>
        -: 2795:struct __is_valid_bind_return
        -: 2796:{
        -: 2797:    static const bool value = false;
        -: 2798:};
        -: 2799:
        -: 2800:template <class _Fp, class ..._BoundArgs, class _TupleUj>
        -: 2801:struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
        -: 2802:{
        -: 2803:    static const bool value = __invokable<_Fp,
        -: 2804:                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
        -: 2805:};
        -: 2806:
        -: 2807:template <class _Fp, class ..._BoundArgs, class _TupleUj>
        -: 2808:struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
        -: 2809:{
        -: 2810:    static const bool value = __invokable<_Fp,
        -: 2811:                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
        -: 2812:};
        -: 2813:
        -: 2814:template <class _Fp, class _BoundArgs, class _TupleUj,
        -: 2815:          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
        -: 2816:struct __bind_return;
        -: 2817:
        -: 2818:template <class _Fp, class ..._BoundArgs, class _TupleUj>
        -: 2819:struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
        -: 2820:{
        -: 2821:    typedef typename __invoke_of
        -: 2822:    <
        -: 2823:        _Fp&,
        -: 2824:        typename __mu_return
        -: 2825:        <
        -: 2826:            _BoundArgs,
        -: 2827:            _TupleUj
        -: 2828:        >::type...
        -: 2829:    >::type type;
        -: 2830:};
        -: 2831:
        -: 2832:template <class _Fp, class ..._BoundArgs, class _TupleUj>
        -: 2833:struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
        -: 2834:{
        -: 2835:    typedef typename __invoke_of
        -: 2836:    <
        -: 2837:        _Fp&,
        -: 2838:        typename __mu_return
        -: 2839:        <
        -: 2840:            const _BoundArgs,
        -: 2841:            _TupleUj
        -: 2842:        >::type...
        -: 2843:    >::type type;
        -: 2844:};
        -: 2845:
        -: 2846:template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
        -: 2847:inline _LIBCPP_INLINE_VISIBILITY
        -: 2848:typename __bind_return<_Fp, _BoundArgs, _Args>::type
        -: 2849:__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
        -: 2850:                _Args&& __args)
        -: 2851:{
        -: 2852:    return _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::get<_Indx>(__bound_args), __args)...);
        -: 2853:}
        -: 2854:
        -: 2855:template<class _Fp, class ..._BoundArgs>
        -: 2856:class __bind
        -: 2857:    : public __weak_result_type<typename decay<_Fp>::type>
        -: 2858:{
        -: 2859:protected:
        -: 2860:    typedef typename decay<_Fp>::type _Fd;
        -: 2861:    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
        -: 2862:private:
        -: 2863:    _Fd __f_;
        -: 2864:    _Td __bound_args_;
        -: 2865:
        -: 2866:    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
        -: 2867:public:
        -: 2868:    template <class _Gp, class ..._BA,
        -: 2869:              class = typename enable_if
        -: 2870:                               <
        -: 2871:                                  is_constructible<_Fd, _Gp>::value &&
        -: 2872:                                  !is_same<typename remove_reference<_Gp>::type,
        -: 2873:                                           __bind>::value
        -: 2874:                               >::type>
        -: 2875:      _LIBCPP_INLINE_VISIBILITY
        -: 2876:      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        -: 2877:        : __f_(_VSTD::forward<_Gp>(__f)),
        -: 2878:          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}
        -: 2879:
        -: 2880:    template <class ..._Args>
        -: 2881:        _LIBCPP_INLINE_VISIBILITY
        -: 2882:        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        -: 2883:        operator()(_Args&& ...__args)
        -: 2884:        {
        -: 2885:            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
        -: 2886:                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        -: 2887:        }
        -: 2888:
        -: 2889:    template <class ..._Args>
        -: 2890:        _LIBCPP_INLINE_VISIBILITY
        -: 2891:        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        -: 2892:        operator()(_Args&& ...__args) const
        -: 2893:        {
        -: 2894:            return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),
        -: 2895:                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
        -: 2896:        }
        -: 2897:};
        -: 2898:
        -: 2899:template<class _Fp, class ..._BoundArgs>
        -: 2900:struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};
        -: 2901:
        -: 2902:template<class _Rp, class _Fp, class ..._BoundArgs>
        -: 2903:class __bind_r
        -: 2904:    : public __bind<_Fp, _BoundArgs...>
        -: 2905:{
        -: 2906:    typedef __bind<_Fp, _BoundArgs...> base;
        -: 2907:    typedef typename base::_Fd _Fd;
        -: 2908:    typedef typename base::_Td _Td;
        -: 2909:public:
        -: 2910:    typedef _Rp result_type;
        -: 2911:
        -: 2912:
        -: 2913:    template <class _Gp, class ..._BA,
        -: 2914:              class = typename enable_if
        -: 2915:                               <
        -: 2916:                                  is_constructible<_Fd, _Gp>::value &&
        -: 2917:                                  !is_same<typename remove_reference<_Gp>::type,
        -: 2918:                                           __bind_r>::value
        -: 2919:                               >::type>
        -: 2920:      _LIBCPP_INLINE_VISIBILITY
        -: 2921:      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        -: 2922:        : base(_VSTD::forward<_Gp>(__f),
        -: 2923:               _VSTD::forward<_BA>(__bound_args)...) {}
        -: 2924:
        -: 2925:    template <class ..._Args>
        -: 2926:        _LIBCPP_INLINE_VISIBILITY
        -: 2927:        typename enable_if
        -: 2928:        <
        -: 2929:            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
        -: 2930:                           result_type>::value || is_void<_Rp>::value,
        -: 2931:            result_type
        -: 2932:        >::type
        -: 2933:        operator()(_Args&& ...__args)
        -: 2934:        {
        -: 2935:            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        -: 2936:            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);
        -: 2937:        }
        -: 2938:
        -: 2939:    template <class ..._Args>
        -: 2940:        _LIBCPP_INLINE_VISIBILITY
        -: 2941:        typename enable_if
        -: 2942:        <
        -: 2943:            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
        -: 2944:                           result_type>::value || is_void<_Rp>::value,
        -: 2945:            result_type
        -: 2946:        >::type
        -: 2947:        operator()(_Args&& ...__args) const
        -: 2948:        {
        -: 2949:            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        -: 2950:            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);
        -: 2951:        }
        -: 2952:};
        -: 2953:
        -: 2954:template<class _Rp, class _Fp, class ..._BoundArgs>
        -: 2955:struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};
        -: 2956:
        -: 2957:template<class _Fp, class ..._BoundArgs>
        -: 2958:inline _LIBCPP_INLINE_VISIBILITY
        -: 2959:__bind<_Fp, _BoundArgs...>
        -: 2960:bind(_Fp&& __f, _BoundArgs&&... __bound_args)
        -: 2961:{
        -: 2962:    typedef __bind<_Fp, _BoundArgs...> type;
        -: 2963:    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
        -: 2964:}
        -: 2965:
        -: 2966:template<class _Rp, class _Fp, class ..._BoundArgs>
        -: 2967:inline _LIBCPP_INLINE_VISIBILITY
        -: 2968:__bind_r<_Rp, _Fp, _BoundArgs...>
        -: 2969:bind(_Fp&& __f, _BoundArgs&&... __bound_args)
        -: 2970:{
        -: 2971:    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
        -: 2972:    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
        -: 2973:}
        -: 2974:
        -: 2975:#endif  // _LIBCPP_CXX03_LANG
        -: 2976:
        -: 2977:#if _LIBCPP_STD_VER > 14
        -: 2978:
        -: 2979:template <class _Fn, class ..._Args>
        -: 2980:invoke_result_t<_Fn, _Args...>
        -: 2981:invoke(_Fn&& __f, _Args&&... __args)
        -: 2982:    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
        -: 2983:{
        -: 2984:    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);
        -: 2985:}
        -: 2986:
        -: 2987:template <class _DecayFunc>
        -: 2988:class _LIBCPP_TEMPLATE_VIS __not_fn_imp {
        -: 2989:  _DecayFunc __fd;
        -: 2990:
        -: 2991:public:
        -: 2992:    __not_fn_imp() = delete;
        -: 2993:
        -: 2994:    template <class ..._Args>
        -: 2995:    _LIBCPP_INLINE_VISIBILITY
        -: 2996:    auto operator()(_Args&& ...__args) &
        -: 2997:            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
        -: 2998:        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
        -: 2999:        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }
        -: 3000:
        -: 3001:    template <class ..._Args>
        -: 3002:    _LIBCPP_INLINE_VISIBILITY
        -: 3003:    auto operator()(_Args&& ...__args) &&
        -: 3004:            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
        -: 3005:        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
        -: 3006:        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }
        -: 3007:
        -: 3008:    template <class ..._Args>
        -: 3009:    _LIBCPP_INLINE_VISIBILITY
        -: 3010:    auto operator()(_Args&& ...__args) const&
        -: 3011:            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))
        -: 3012:        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))
        -: 3013:        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }
        -: 3014:
        -: 3015:
        -: 3016:    template <class ..._Args>
        -: 3017:    _LIBCPP_INLINE_VISIBILITY
        -: 3018:    auto operator()(_Args&& ...__args) const&&
        -: 3019:            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))
        -: 3020:        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))
        -: 3021:        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }
        -: 3022:
        -: 3023:private:
        -: 3024:    template <class _RawFunc,
        -: 3025:              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>
        -: 3026:    _LIBCPP_INLINE_VISIBILITY
        -: 3027:    explicit __not_fn_imp(_RawFunc&& __rf)
        -: 3028:        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}
        -: 3029:
        -: 3030:    template <class _RawFunc>
        -: 3031:    friend inline _LIBCPP_INLINE_VISIBILITY
        -: 3032:    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
        -: 3033:};
        -: 3034:
        -: 3035:template <class _RawFunc>
        -: 3036:inline _LIBCPP_INLINE_VISIBILITY
        -: 3037:__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
        -: 3038:    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));
        -: 3039:}
        -: 3040:
        -: 3041:#endif
        -: 3042:
        -: 3043:// struct hash<T*> in <memory>
        -: 3044:
        -: 3045:template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
        -: 3046:pair<_ForwardIterator1, _ForwardIterator1> _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 3047:__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        -: 3048:         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
        -: 3049:         forward_iterator_tag, forward_iterator_tag)
        -: 3050:{
        -: 3051:    if (__first2 == __last2)
        -: 3052:        return _VSTD::make_pair(__first1, __first1);  // Everything matches an empty sequence
        -: 3053:    while (true)
        -: 3054:    {
        -: 3055:        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
        -: 3056:        while (true)
        -: 3057:        {
        -: 3058:            if (__first1 == __last1)  // return __last1 if no element matches *__first2
        -: 3059:                return _VSTD::make_pair(__last1, __last1);
        -: 3060:            if (__pred(*__first1, *__first2))
        -: 3061:                break;
        -: 3062:            ++__first1;
        -: 3063:        }
        -: 3064:        // *__first1 matches *__first2, now match elements after here
        -: 3065:        _ForwardIterator1 __m1 = __first1;
        -: 3066:        _ForwardIterator2 __m2 = __first2;
        -: 3067:        while (true)
        -: 3068:        {
        -: 3069:            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
        -: 3070:                return _VSTD::make_pair(__first1, __m1);
        -: 3071:            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found
        -: 3072:                return _VSTD::make_pair(__last1, __last1);
        -: 3073:            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1
        -: 3074:            {
        -: 3075:                ++__first1;
        -: 3076:                break;
        -: 3077:            }  // else there is a match, check next elements
        -: 3078:        }
        -: 3079:    }
        -: 3080:}
        -: 3081:
        -: 3082:template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
        -: 3083:_LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 3084:pair<_RandomAccessIterator1, _RandomAccessIterator1>
        -: 3085:__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        -: 3086:         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
        -: 3087:           random_access_iterator_tag, random_access_iterator_tag)
        -: 3088:{
        -: 3089:    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
        -: 3090:    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;
        -: 3091:    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
        -: 3092:    const _D2 __len2 = __last2 - __first2;
        -: 3093:    if (__len2 == 0)
        -: 3094:        return _VSTD::make_pair(__first1, __first1);
        -: 3095:    const _D1 __len1 = __last1 - __first1;
        -: 3096:    if (__len1 < __len2)
        -: 3097:        return _VSTD::make_pair(__last1, __last1);
        -: 3098:    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here
        -: 3099:
        -: 3100:    while (true)
        -: 3101:    {
        -: 3102:        while (true)
        -: 3103:        {
        -: 3104:            if (__first1 == __s)
        -: 3105:                return _VSTD::make_pair(__last1, __last1);
        -: 3106:            if (__pred(*__first1, *__first2))
        -: 3107:                break;
        -: 3108:            ++__first1;
        -: 3109:        }
        -: 3110:
        -: 3111:        _RandomAccessIterator1 __m1 = __first1;
        -: 3112:        _RandomAccessIterator2 __m2 = __first2;
        -: 3113:         while (true)
        -: 3114:         {
        -: 3115:             if (++__m2 == __last2)
        -: 3116:                 return _VSTD::make_pair(__first1, __first1 + __len2);
        -: 3117:             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source
        -: 3118:             if (!__pred(*__m1, *__m2))
        -: 3119:             {
        -: 3120:                 ++__first1;
        -: 3121:                 break;
        -: 3122:             }
        -: 3123:         }
        -: 3124:    }
        -: 3125:}
        -: 3126:
        -: 3127:#if _LIBCPP_STD_VER > 14
        -: 3128:
        -: 3129:// default searcher
        -: 3130:template<class _ForwardIterator, class _BinaryPredicate = equal_to<>>
        -: 3131:class _LIBCPP_TYPE_VIS default_searcher {
        -: 3132:public:
        -: 3133:    _LIBCPP_INLINE_VISIBILITY
        -: 3134:    default_searcher(_ForwardIterator __f, _ForwardIterator __l,
        -: 3135:                       _BinaryPredicate __p = _BinaryPredicate())
        -: 3136:        : __first_(__f), __last_(__l), __pred_(__p) {}
        -: 3137:
        -: 3138:    template <typename _ForwardIterator2>
        -: 3139:    _LIBCPP_INLINE_VISIBILITY
        -: 3140:    pair<_ForwardIterator2, _ForwardIterator2>
        -: 3141:    operator () (_ForwardIterator2 __f, _ForwardIterator2 __l) const
        -: 3142:    {
        -: 3143:        return _VSTD::__search(__f, __l, __first_, __last_, __pred_,
        -: 3144:            typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category(),
        -: 3145:            typename _VSTD::iterator_traits<_ForwardIterator2>::iterator_category());
        -: 3146:    }
        -: 3147:
        -: 3148:private:
        -: 3149:    _ForwardIterator __first_;
        -: 3150:    _ForwardIterator __last_;
        -: 3151:    _BinaryPredicate __pred_;
        -: 3152:    };
        -: 3153:
        -: 3154:#endif // _LIBCPP_STD_VER > 14
        -: 3155:
        -: 3156:#if _LIBCPP_STD_VER > 17
        -: 3157:template <class _Tp>
        -: 3158:using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
        -: 3159:
        -: 3160:template <class _Tp>
        -: 3161:using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
        -: 3162:#endif // > C++17
        -: 3163:
        -: 3164:template <class _Container, class _Predicate>
        -: 3165:inline typename _Container::size_type
        -: 3166:__libcpp_erase_if_container(_Container& __c, _Predicate __pred) {
        -: 3167:  typename _Container::size_type __old_size = __c.size();
        -: 3168:
        -: 3169:  const typename _Container::iterator __last = __c.end();
        -: 3170:  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
        -: 3171:    if (__pred(*__iter))
        -: 3172:      __iter = __c.erase(__iter);
        -: 3173:    else
        -: 3174:      ++__iter;
        -: 3175:  }
        -: 3176:
        -: 3177:  return __old_size - __c.size();
        -: 3178:}
        -: 3179:
        -: 3180:_LIBCPP_END_NAMESPACE_STD
        -: 3181:
        -: 3182:#endif  // _LIBCPP_FUNCTIONAL
